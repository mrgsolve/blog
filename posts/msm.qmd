library(msm)
library(mrgsolve)
library(dplyr)
library(minqa)

options(pillar.width = Inf)

statetable.msm(state, PTNUM, data=cav)

qq <- rbind(
  c(0, 0.25, 0, 0.25), 
  c(0.166, 0, 0.166, 0.166),
  c(0, 0.25, 0, 0.25), 
  c(0, 0, 0, 0)
)

cav.msm <- msm(
  state ~ years, 
  subject = PTNUM, 
  data = cav,
  qmatrix = qq, 
  deathexact = 4
)

cav.msm

data <- rename(
  as_tibble(cav), 
  ID = PTNUM, 
  time = years
) 

code <- '
$CMT A1 A2 A3 A4

$PLUGIN autodec evtools

$PARAM
k12 = 0.1/2 
k21 = 0.1/2
k23 = 0.1/2
k32 = 0.1/2
k14 = 0.1/2
k24 = 0.1/2
k34 = 0.1/2

$INPUT 
firstobs = 0
state = 1
statemax = 1

$GLOBAL
void resetCMT(databox& self, const double amt, const int cmt) {
  evt::ev x = evt::bolus(amt, cmt);
  x.evid = 8;
  self.push(x);
}

$MAIN 
A1_0 = 1;
A2_0 = 0; 
A3_0 = 0; 
A4_0 = 0;

$DES

dxdt_A1 = -A1 * k12 + A2 * k21                       - A1 * k14;
dxdt_A2 =  A1 * k12 - A2 * k21 - A2 * k23 + A3 * k32 - A2 * k24;
dxdt_A3 =  A2 * k23 - A3 * k32                       - A3 * k34;
dxdt_A4 =  A1 * k14 + A2 * k24 + A3 * k34;

$ERROR

if(state==1 && EVID==0) Y = A1;
if(state==2 && EVID==0) Y = A2;
if(state==3 && EVID==0) Y = A3;
if(state==4 && EVID==0) {
  Y = A1 * k14 + A2 * k24 + A3 * k34;
}

if(EVID==0) {
  for(int i = 1; i <= 4; ++i) {
    resetCMT(self, 0, i);
  }
  resetCMT(self, 1, state);
}

$CAPTURE Y
'

mod <- mcode("msm", code)

theta <- as.numeric(param(mod))
theta <- theta[grep("^k", names(theta))]
tnames <- names(theta)

pred <- function(p, data) {
  p <- lapply(p, exp)
  names(p) <- tnames
  mod <- param(mod, p)
  out <- mrgsim_q(mod, data)
  -2*sum(log(out$Y))
}

fit <- newuoa(
  par = log(theta), 
  fn = pred, 
  data = data, 
  control = list(iprint = 0)
)

est <- exp(fit$par)
names(est) <- tnames

est
