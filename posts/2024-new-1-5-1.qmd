---
title: "New in version 1.5.1"
author: Kyle Baron
date: 7/26/2024
description: > 
  mrgsolve version 1.5.1 was released to CRAN in July, 2024. This release 
  features new functions to write a model back to a file in either yaml format
  or native mrgsolve. 
categories:
- mwrite
- evtools
- dynamic-dosing
- pkmodel
- data set
- new release
editor_options: 
  chunk_output_type: console
---

## mwrite

mrgsolve has used `mread()` since the start to _read_, parse, and compile a
model. The 1.5.1 release introduces functions to _write_ the resulting model 
back to a file. 


Let's illustrate with a model from the model library inside the mrgsolve 
package. 

```{r}
#| message: false
library(mrgsolve)
library(dplyr)

mod <- modlib("1005")
```
We are using a model that was estimated in NONMEM. So the `$NMXML` code block 
is in play; this imports THETAs, OMEGAs, and SIGMAs from the `root.xml` file 
generated by NONMEM. 

```{r}
blocks(mod, NMXML)
```


The `$NMXML` (and `$NMEXT`) blocks are very convenient for making sure that
mrgsolve is using the same estimates that NONMEM found during estimation.

But what if we wanted to share this model with a collaborator? We can't just 
send this file around with out packaging up the completed NONMEM run as well. 

We might also want to make updates to this model. For example, 

```{r}
mod <- param(mod, THETA1 = 8.51, SEX = 1)

mod <- update(
  mod, 
  end = 168, 
  rtol = 1e-5,
  ss_rtol = 1e-4, 
  outvars  = "IPRED"
)
```

This model is now set up for my simulations and I want to save this model 
back to a file. With mrgsolve 1.5.1, we can write the model back to a file 
with `mwrite_yaml()` (yaml structured code) or `mwrite_cpp()` (native'
mrgsolve format). 

```{r}
mwrite_yaml(mod, file = "1005-updated.mod")
```


::: {.callout-note collapse="true" appearance="simple"}
# See the code in yaml format

```{c, code = readLines("1005-updated.mod"), eval = FALSE}
#| filename: 1005-updated.mod

```
:::

Now, we have the updated model in a format suitable for transport and that 
reflects all the changes we've made to the model object so far. 


To read the model back into R, we call `mread_yaml()`

```{r}
mod <- mread_yaml("1005-updated.mod", model = "updated")

mod
```

and we have the model object back in hand, ready to simulate. Notice that 
we've read the model back with no knowledge of the estimated NONMEM model. All 
of those estimates are now _hard-coded_ into the model file. Of course, if 
the model gets re-estimated and the estimates change, this derived file will 
be out of date with that run and you'll have to repeat this process to get
updated estimated into the model. 


Note that you can also write the model out directly to native mrgsolve format. 

```{r}
mwrite_cpp(mod, file = "1005-updated.txt")
```

In this case, load the model back with `mread()` as you would any other model

```{r}
mod <- mread("1005-updated.txt")
```

There is also a translator form the `yaml` format to the native mrgsolve 
format. Call `yaml_to_cpp()` to do this conversion

```{r}
x <- yaml_to_cpp("1005-updated.mod", model = "1005-converted")

print(basename(x))
```


## Addition to `evtools` plugin

The 1.5.1 mrgsolve release also adds a new function to the `evtools` plugin 
that allows you to _replace_ the amount in a specific compartment with a new 
amount. The function is `evt::replace()` and it works just like `evt::bolus()`
but the compartment is zeroed-out before putting the new "dose" into the 
compartment. 


The replace functionality uses `EVID = 8` that mrgsolve already knows how to 
handle in event objects and data sets. The addition to the `evtools` plugin
allows you to easily access this functionality from within your model. To 
zero-out the first compartment and reset the second compartment to 100 at 
24 hours into the simulation, the code might look like this

```{c, eval = FALSE}
$PLUGIN evtools

$PK
if(TIME==24) {
  evt::replace(self,   0, 1);
  evt::replace(self, 100, 2);
}
```

## Refactored `as_data_set()`

This release also expands the flexibility of `as_data_set()`, which can combine
event objects or data frames into a single data set for simulation. 

For example, if we have two event objects, we can combine them into a single 
object which is a data frame

```{r}
e1 <- ev(amt = 100) 
e2 <- ev(amt = 200)

as_data_set(e1, e2)
```

We can also make this data set with upper case names using the `evd()` 
constructor

```{r}
e3 <- evd(amt = 100) 
e4 <- evd(amt = 200)

as_data_set(e3, e4)
```

Or by calling `uctran()` on the result

```{r}
as_data_set(e1, e2) %>% uctran()
```

The 1.5.1 release gives you more flexibility in combining objects. If you have 
objects with lower and upper case names, mrgsolve will follow the pattern 
in the first object

```{r}
as_data_set(e1, e3, e2, e4)
```

The 1.5.1 release also lets you combine data frames or a mixture of data frame
and event objects

```{r}
d1 <- mutate(e1, amt = 600) %>% ev_rep(1:2)
d3 <- mutate(e3, amt = 50) %>% ev_rep(1:4)

as_data_set(d3, e3, e4, d1)
```

## nm-vars convenience functions

The `nm-vars` plugin gives you syntax in your mrgsolve model that is similar
to what you can use in your NONMEM model. Using this plugin makes it much 
easier to translate between the two formats. 

New in 1.5.1, we have aliases for additional functions

- `DEXP()`
- `LOG10()`
- `COS()`
- `SIN()`

These are just upper case versions of functions that are already in `C++`. 

## Error when `KA` is (about) equal to `K10`

The `$PKMODEL` block allows you to write mrgsolve models which have analytical 
solutions to them (you don't need to solve ODEs). The math behind these models
breaks down when `KA` is equal to `K10` (`CL/V`). Starting with version 1.5.1, 
mrgsolve will give an error when this is the case. 





