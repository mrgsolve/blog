---
title: "Update: Validate translation from NONMEM"
author: Kyle Baron
date: 3/6/2023
description: > 
  With mrgsolve version 1.0.8, there is a more complete way to validate your 
  model against a completed NONMEM estimation run.
categories:
- validation
---

# Introduction

I wrote a [post](https://mrgsolve.org/blog/posts/2022-05-validate-translation/) in May 2022 about using NONMEM-generated `PRED` from a completed
estimation run to validate the coding of the equivalent model in mrgsolve. This
post will show you how to do a similar validation, but this time using `IPRED`
to validate the translation. 

To help with the big picture, the steps are 

1. Read in the model estimation data set
1. Read in NONMEM  `$TABLE` outputs which include `IPRED` and all the model `ETA` values
1. Join the table outputs to the model estimation data set
1. Simulate from the candidate mrgsolve model, using the `etasrc = "data.all"` argument to [`mrgsim()`](https://mrgsolve.org/docs/reference/mrgsim.html), new in 
  version 1.0.8
1. Compare NONMEM-generated `IPRED` against mrgsolve-generated `IPRED`

I'll detail these steps in the following sections or you can jump to 
the complete workflow in @sec-complete-workflow.

You can get more information on how this all works in the `mrgsim()`
help topic

```{r, eval = FALSE}
?mrgsim
```

with mrgsolve 1.0.8 installed or check   [here](https://mrgsolve.org/docs/reference/mrgsim.html).

# Setup

```{r, message = FALSE, warning = FALSE}
library(mrgsolve)
library(readr)
library(dplyr)
library(here)
library(glue)
```

```{r, include = FALSE}
options(pillar.width = Inf)
```


# Leveraging outputs from NONMEM for validation

## Population-level predictions

The basic idea from the previous post was to use `PRED` which is generated 
by NONMEM for output in your `$TABLE` files. 

```{r, message = FALSE}
tab1 <- read_table("model/pk/106/106.tab", skip = 1)

head(tab1)
```

This comes automatically when you create `$TABLE` outputs unless you 
suppress it with the `NOAPPEND` option. 

`PRED` is the population-predicted value or the prediction with all `ETA`
($\eta$) and `EPS` ($\epsilon$) set to `0`. When we validate a model based on
`PRED`, we can verify several different aspects of the model, including handling
of the data set (e.g. observations and dosing interventions), the covariate
model, and the coding of the differential equations to name a few. What this
approach doesn't check is the placement of the $\eta$s in the model.

## Individual-level predictions

Notice we also have `IPRED`, or the individual-predicted value, in the `$TABLE`
output shown above. I put `IPRED` into the output and it's a common practice to
do this.


```{r, eval = FALSE, filename = "106.ctl"}
#| code-line-numbers: false
$ERROR
IPRED = A(2)/V2

$TABLE IPRED FILE = 106.tab
```

The `IPRED` is a model prediction like `PRED`, but it includes the individual
$\eta$ generated by NONMEM. Note that these $\eta$ are not random draws
from $\Omega$; but rather they are post-hoc $\eta$ values for specific 
individuals, conditional on each individual's data in the problem. If we can validate against `IPRED`
rather than `PRED`, we can check all aspects of the data and model that we
were checking with `PRED`, but also check the $\eta$ placements as well, including any transformations of 
$\eta$.

To get $\eta$ into the output, I wrote

```{r, eval = FALSE, filename = "106.ctl"}
#| code-line-numbers: false
$TABLE ETAS(1:LAST) FILE = 106par.tab
```

This will give outputs `ETA1`, `ETA2`, `ETA3` etc. In this example, I put these in a separate
`$TABLE` file, but you don't have to do this.

```{r, message = FALSE}
tab2 <- read_table("model/pk/106/106par.tab", skip = 1)

head(tab2)
```

I have both `tab1` and `tab2` data frames keyed by a `NUM` column that numbers the rows of the 
output; this makes it easy to generate a single data frame which includes all 
outputs

```{r}
tab <- left_join(tab1, tab2, by = "NUM")

head(tab)
```

# Join NONMEM outputs with the model estimation data

Now, we'll read in the model estimation data set and join on the `$TABLE`
outputs, again by the `NUM` column

```{r, message = FALSE}
nmdata <- read_csv("data/derived/analysis3.csv", na = '.')

data <- left_join(tab, nmdata, by = "NUM")
```

Note that we've put `tab` on the left to ensure that we only include records
that were not `IGNORE`d by NONMEM. 

This `data` object includes the following: 

1. The model estimation data, including dosing records, observation
   records and covariates
2. All of the post-hoc $\eta$ values
3. The individual predicted model outputs (`IPRED`)

::: {.callout-note collapse="true" appearance="simple" icon="false"}
# See the data
```{r}
head(data)
```
:::

# Simulate with `etasrc = "data.all"`

Now we want to use mrgsolve to simulate its version of `IPRED` and 
we'll compare that result to the NONMEM-generated `IPRED` as our validation 
of the mrgsolve setup.

```{r, message = FALSE}
mod <- mread_cache("106.txt", project = here("model/pk"))
```


::: {.callout-note collapse="true" appearance="simple" icon="false"}
# See the model code

```{c, eval = FALSE, code = mod@code, filename = "106.txt"}

```
:::

This model is already capturing `IPRED`

```{r}
outvars(mod)
```


We will do this with the `etasrc` argument to `mrgsim()` which is [new with
version 1.0.8](https://mrgsolve.org/blog/posts/2023-new-1.0.8.html). `etasrc`
lets you instruct mrgsolve to look at the data set for columns named `ETA1`,
`ETA2`, etc and use those values for $\eta$ rather than generating  new, random
$\eta$ from $\Omega$.

The simulation looks like this

```{r}
out <- mrgsim(
  mod, 
  data      = data, 
  etasrc    = "data.all", 
  obsonly   = TRUE, 
  Req       = "MRG = IPRED", 
  carry_out = "NM = IPRED, PRED"
)
```

In the above `mrgsim()` call, we use `Req` to request the `IPRED` output 
from the mrgsolve model and we use the `carry_out` argument to copy the 
`IPRED` value from the input data set, the NONMEM-generated value. I've also
asked for `PRED` to get copied into the output so we can compare.

```{r}
head(out)
```

Now we have `IPRED` generated by mrgsolve (`MRG`) and by NONMEM (`NM`).

# Check the result

You can check the result graphically

::: {.callout-note collapse="true" appearance="simple" icon="false"}
# See the plotting code

```{r}
#| fig-width: 6
library(ggplot2)
pick <- filter(out, ID <= 9)
p <- ggplot(data = pick) + 
  geom_point(aes(TIME, MRG)) + 
  geom_line(aes(TIME, NM), color = "blue3") +
  ylab("IPRED") + facet_wrap(~ID, scales = "free_y") + 
  ggtitle("Points: mrgsolve, Lines: NONMEM") + theme_bw()
```
:::

```{r, echo = FALSE}
p
```



```{r}
plot(out$MRG, out$NM)
```

Or by some summary of the discrepancy 

```{r}
summary(out$MRG - out$NM)

summary(100*(out$MRG - out$NM)/out$NM)
```


# Complete workflow {#sec-complete-workflow}

Here's the complete workflow. For projects, I put this into a standalone 
script called `validate.R` and just use it to check my simulation models
as model development is going on.

```{r, message = FALSE, filename = "validate.R"}
run <- 106

# Read the analysis data set
nmdata <- read_csv("data/derived/analysis3.csv", na = '.')

# Read NM table outputs
tab1 <- read_table(glue("model/pk/{run}/{run}.tab"), skip = 1)
tab2 <- read_table(glue("model/pk/{run}/{run}par.tab"), skip = 1)
tab <- left_join(tab1, tab2, by = "NUM")

# Join
data <- left_join(tab, nmdata, by = "NUM")

# The mrgsolve simulation model
mod <- mread_cache(glue("{run}.txt"), project = here("model/pk"))

# Simulate
out <- mrgsim(
  mod, 
  data      = data, 
  etasrc    = "data.all", 
  obsonly   = TRUE, 
  Req       = "MRG = IPRED", 
  carry_out = "NM = IPRED"
)

# Compare
summary(out$MRG - out$NM)
```
