---
title: "Update: Validate translation from NONMEM"
author: Kyle Baron
date: 3/6/2023
description: > 
  With mrgsolve version 1.0.8, there is a more complete way to validate your 
  model against a completed NONMEM estimation run.
categories:
- new release
---

# Introduction

I wrote a post in May 2022 about using NONMEM-generated `PRED` from a completed
estimation run to validate the coding of the equivalent model in mrgsolve. This
post will show you how to do a similar validation, but this time using `IPRED`
to validate the translation. 

To help with the big picture, the steps are 

1. Read in the model estimation data set
1. Read in NONMEM  `$TABLE` outputs which include `IPRED` and all the model `ETA` values
1. Join the table outputs to the model estimation data set
1. Simulate from the candidate mrgsolve model, using the new `etasrc = "data.all'` argument to `mrgsim()`
1. Compare NONMEM-generated `IPRED` against mrgsolve-generated `IPRED`

We'll detail these steps in the following sections. 


# Setup

```{r, message = FALSE, warning = FALSE}
library(mrgsolve)
library(readr)
library(dplyr)
library(here)
```

```{r, include = FALSE}
options(pillar.width = Inf)
```


# Leveraging outputs from NONMEM for validation

## Population-level predictions

The basic idea from the previous post was to use `PRED` which is generated 
by NONMEM for output in your `$TABLE` files. 

```{r, message = FALSE}
tab1 <- read_table("model/pk/106/106.tab", skip = 1)

head(tab1)
```

This comes automatically when you create `$TABLE` outputs unless you 
suppress it with the `NOAPPEND` option. 

`PRED` is the population-predicted value or the prediction with all
$\eta$ and $\epsilon$ set to `0`. When we validate a model based on `PRED`, 
we can verify several different aspects of the model, including handling
of the data set (e.g. observations and dosing interventions), the covariate
model, and the coding of the differential equations to name a few. What this approach 
doesn't check is the placement of the $\eta$s in the model.

## Individual-level predictions

Notice we also have `IPRED`, or the individual-predicted value, in the 
`$TABLE` output shown. I put `IPRED` into the output and it's a standard practice 
to do this.


```{r, eval = FALSE, filename = "106.ctl"}
$ERROR
IPRED = A(2)/V2

$TABLE IPRED FILE = 106.tab
```

The `IPRED` is a model prediction like `PRED`, but it includes the individual
$\eta$ generated by NONMEM. Note that these $\eta$ are not random draws
from $\Omega$; but rather they are post-hoc $\eta$ values for specific 
individuals, conditional on each individual's data in the problem. If we can validate against `IPRED`
rather than `PRED`, we can check all aspects of the data and model that we
were checking with `PRED` but also check the $\eta$ placements as well, including any transformations of 
$\eta$.

To get $\eta$ into the output, I wrote

```{r, eval = FALSE, filename = "106.ctl"}
$TABLE ETAS(1:LAST) FILE = 106par.tab
```

This will give outputs `ETA1`, `ETA2`, `ETA3` etc. In this example, I put these in a separate
`$TABLE` file but you don't have to do this.

```{r, message = FALSE}
tab2 <- read_table("model/pk/106/106par.tab", skip = 1)

head(tab2)
```

I have both `tab1` and `tab2` data frames keyed by a `NUM` column that numbers the rows of the 
output; this makes it easy to generate a single data frame which includes all 
outputs

```{r}
tab <- left_join(tab1, tab2, by = "NUM")

head(tab)
```

# Join NONMEM outputs with the model estimation data

Now, we'll read in the model estimation data set and join on the `$TABLE`
outputs, again by the `NUM` column

```{r, message = FALSE}
nmdata <- read_csv("data/derived/analysis3.csv", na = '.')

data <- left_join(tab, nmdata, by = "NUM")
```

Note that we've put `tab` on the left to ensure that we only include records
that were not `IGNORE`d by NONMEM. 

This `data` object includes the following: 

1. The model estimation data, including dosing records, observation
   records and covariates
2. All of the post-hoc $\eta$ values
3. The individual predicted model outputs (`IPRED`)

# Simulate with `etasrc = "data"`

Now we want to use mrgsolve to simulate it's version of `IPRED` and 
we'll compare that result to the NONMEM-generated `IPRED` as our validation 
of the mrgsolve setup.

```{r}
mod <- mread_cache("106.txt", project = here("model/pk"))
```

This model is already capturing `IPRED`

```{r}
outvars(mod)
```


We will do this with the `etasrc` argument to `mrgsim()` which is 
new with version 1.0.8. `etasrc` lets you instruct mrgsolve to 
look at the data set for columns named `ETA1`, `ETA2`, etc and use 
those values for $\eta$ rather than generating $\eta$ from $\Omega$.

The simulation looks like this

```{r}
out <- mrgsim(
  mod, 
  data = data, 
  etasrc = "data.all", 
  obsonly = TRUE, 
  Req = "MRG = IPRED", 
  carry_out = "NM = IPRED"
)
```


Now we have `IPRED` generated by mrgsolve (`MRG`) and by NONMEM (`NM`).

# Check the result

You can check the result graphically

```{r}
plot(out$MRG, out$NM)
```

Or by some summary of the discrepancy 

```{r}
summary(out$MRG - out$NM)

summary(100*(out$MRG - out$NM)/out$NM)
```


# Complete workflow

Here's the complete workflow 

```{r, message = FALSE}
tab1 <- read_table("model/pk/106/106.tab", skip = 1)
tab2 <- read_table("model/pk/106/106par.tab", skip = 1)
tab <- left_join(tab1, tab2, by = "NUM")

nmdata <- read_csv("data/derived/analysis3.csv", na = '.')

data <- left_join(tab, nmdata, by = "NUM")

mod <- mread_cache("106.txt", project = here("model/pk"))

out <- mrgsim(
  mod, 
  data = data, 
  etasrc = "data.all", 
  obsonly = TRUE, 
  Req = "MRG = IPRED", 
  carry_out = "NM = IPRED"
)

summary(out$MRG - out$NM)
```

