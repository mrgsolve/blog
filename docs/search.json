[
  {
    "objectID": "posts/2023-update-validation.html",
    "href": "posts/2023-update-validation.html",
    "title": "Update: Validate translation from NONMEM",
    "section": "",
    "text": "I wrote a post in May 2022 about using NONMEM-generated PRED from a completed estimation run to validate the coding of the equivalent model in mrgsolve. This post will show you how to do a similar validation, but this time using IPRED to validate the translation.\nTo help with the big picture, the steps are\n\nRead in the model estimation data set\nRead in NONMEM $TABLE outputs which include IPRED and all the model ETA values\nJoin the table outputs to the model estimation data set\nSimulate from the candidate mrgsolve model, using the new etasrc = \"data.all' argument to mrgsim(), new in version 1.0.8\nCompare NONMEM-generated IPRED against mrgsolve-generated IPRED\n\nI’ll detail these steps in the following sections."
  },
  {
    "objectID": "posts/2023-update-validation.html#population-level-predictions",
    "href": "posts/2023-update-validation.html#population-level-predictions",
    "title": "Update: Validate translation from NONMEM",
    "section": "3.1 Population-level predictions",
    "text": "3.1 Population-level predictions\nThe basic idea from the previous post was to use PRED which is generated by NONMEM for output in your $TABLE files.\n\ntab1 <- read_table(\"model/pk/106/106.tab\", skip = 1)\n\nhead(tab1)\n\n# A tibble: 6 × 8\n    NUM IPRED    NPDE   CWRES    DV  PRED    RES    WRES\n  <dbl> <dbl>   <dbl>   <dbl> <dbl> <dbl>  <dbl>   <dbl>\n1     1   0    0       0        0     0    0      0     \n2     2  68.5 -0.633  -0.512   61.0  60.6  0.422 -0.533 \n3     3  90.8  0.403   0.126   91.0  78.5 12.4    0.142 \n4     4  97.3  1.68    1.44   122.   83.0 39.2    1.63  \n5     5  96.7  1.71    1.69   126.   82.2 43.9    1.91  \n6     6  88.7 -0.0334 -0.0527  84.7  75.5  9.20  -0.0941\n\n\nThis comes automatically when you create $TABLE outputs unless you suppress it with the NOAPPEND option.\nPRED is the population-predicted value or the prediction with all \\(\\eta\\) and \\(\\epsilon\\) set to 0. When we validate a model based on PRED, we can verify several different aspects of the model, including handling of the data set (e.g. observations and dosing interventions), the covariate model, and the coding of the differential equations to name a few. What this approach doesn’t check is the placement of the \\(\\eta\\)s in the model."
  },
  {
    "objectID": "posts/2023-update-validation.html#individual-level-predictions",
    "href": "posts/2023-update-validation.html#individual-level-predictions",
    "title": "Update: Validate translation from NONMEM",
    "section": "3.2 Individual-level predictions",
    "text": "3.2 Individual-level predictions\nNotice we also have IPRED, or the individual-predicted value, in the $TABLE output shown. I put IPRED into the output and it’s a standard practice to do this.\n\n\n\n106.ctl\n\n$ERROR\nIPRED = A(2)/V2\n\n$TABLE IPRED FILE = 106.tab\n\n\nThe IPRED is a model prediction like PRED, but it includes the individual \\(\\eta\\) generated by NONMEM. Note that these \\(\\eta\\) are not random draws from \\(\\Omega\\); but rather they are post-hoc \\(\\eta\\) values for specific individuals, conditional on each individual’s data in the problem. If we can validate against IPRED rather than PRED, we can check all aspects of the data and model that we were checking with PRED but also check the \\(\\eta\\) placements as well, including any transformations of \\(\\eta\\).\nTo get \\(\\eta\\) into the output, I wrote\n\n\n\n106.ctl\n\n$TABLE ETAS(1:LAST) FILE = 106par.tab\n\n\nThis will give outputs ETA1, ETA2, ETA3 etc. In this example, I put these in a separate $TABLE file but you don’t have to do this.\n\ntab2 <- read_table(\"model/pk/106/106par.tab\", skip = 1)\n\nhead(tab2)\n\n# A tibble: 6 × 9\n    NUM    CL    V2     Q    V3    KA   ETA1   ETA2   ETA3\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>  <dbl>  <dbl>\n1     1  2.62  39.8  3.02  53.0  1.39 -0.113 -0.198 -0.144\n2     2  2.62  39.8  3.02  53.0  1.39 -0.113 -0.198 -0.144\n3     3  2.62  39.8  3.02  53.0  1.39 -0.113 -0.198 -0.144\n4     4  2.62  39.8  3.02  53.0  1.39 -0.113 -0.198 -0.144\n5     5  2.62  39.8  3.02  53.0  1.39 -0.113 -0.198 -0.144\n6     6  2.62  39.8  3.02  53.0  1.39 -0.113 -0.198 -0.144\n\n\nI have both tab1 and tab2 data frames keyed by a NUM column that numbers the rows of the output; this makes it easy to generate a single data frame which includes all outputs\n\ntab <- left_join(tab1, tab2, by = \"NUM\")\n\nhead(tab)\n\n# A tibble: 6 × 16\n    NUM IPRED    NPDE   CWRES    DV  PRED    RES    WRES    CL    V2     Q    V3\n  <dbl> <dbl>   <dbl>   <dbl> <dbl> <dbl>  <dbl>   <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1   0    0       0        0     0    0      0       2.62  39.8  3.02  53.0\n2     2  68.5 -0.633  -0.512   61.0  60.6  0.422 -0.533   2.62  39.8  3.02  53.0\n3     3  90.8  0.403   0.126   91.0  78.5 12.4    0.142   2.62  39.8  3.02  53.0\n4     4  97.3  1.68    1.44   122.   83.0 39.2    1.63    2.62  39.8  3.02  53.0\n5     5  96.7  1.71    1.69   126.   82.2 43.9    1.91    2.62  39.8  3.02  53.0\n6     6  88.7 -0.0334 -0.0527  84.7  75.5  9.20  -0.0941  2.62  39.8  3.02  53.0\n     KA   ETA1   ETA2   ETA3\n  <dbl>  <dbl>  <dbl>  <dbl>\n1  1.39 -0.113 -0.198 -0.144\n2  1.39 -0.113 -0.198 -0.144\n3  1.39 -0.113 -0.198 -0.144\n4  1.39 -0.113 -0.198 -0.144\n5  1.39 -0.113 -0.198 -0.144\n6  1.39 -0.113 -0.198 -0.144"
  },
  {
    "objectID": "posts/steady-state.html",
    "href": "posts/steady-state.html",
    "title": "Steady State in mrgsolve",
    "section": "",
    "text": "This blog post describes the mechanism by which mrgsolve finds steady state under this new change set (starting late 2019 to early 2020) and describes some of the settings that users can control to their advantage."
  },
  {
    "objectID": "posts/steady-state.html#tldr",
    "href": "posts/steady-state.html#tldr",
    "title": "Steady State in mrgsolve",
    "section": "1.1 tl;dr",
    "text": "1.1 tl;dr\n\npass ss_n to put an upper cap on number of doses to give when finding SS\npass ss_fixed to silence warnings when ss isn’t met\nset ss_cmt (in [ set ]) to include or exclude certain compartments for consideration when finding SS\nuse SS_ADVANCE logical flag in [ ode ] to not advance certain compartments when mrgsolve is working to find SS"
  },
  {
    "objectID": "posts/steady-state.html#for-example",
    "href": "posts/steady-state.html#for-example",
    "title": "Steady State in mrgsolve",
    "section": "2.1 For example",
    "text": "2.1 For example\nLet’s load a PK model\n\nlibrary(tidyverse)\nlibrary(mrgsolve)\n\nmod <- modlib(\"pk2\")\n\nAnd let’s imagine a 100 mg QD dosing regimen\n\ndose <- ev(amt = 100, ii = 24)\n\nAnd give that dose a large number of times\n\ndose <- mutate(dose, total = 1000)\n\nLet’s just look at trough concentrations and see how the trough develops over the dosing period\n\nmod <- update(mod, delta = 24, end = 24*20, outvars = \"CENT,PERIPH\")\n\nAnd simulate that out\n\nout <- mrgsim_e(mod,dose,recsort=3)\n\n\nplot(out)\n\n\n\n\nObviously, the trough concentration starts to increase and after a certain period stops changing\n\ntail(out) \n\n   ID time     CENT   PERIPH\n17  1  360 53.95222 31.95587\n18  1  384 53.95257 31.95608\n19  1  408 53.95274 31.95618\n20  1  432 53.95281 31.95622\n21  1  456 53.95285 31.95625\n22  1  480 53.95287 31.95626\n\n\nLooking at the compartment amount at the last trough compared to the second to the last trough, the amounts aren’t changing very much. This is how mrgsolve finds steady state: it keeps giving the dose at the dosing interval until the pre-dose concentration stops changing very much."
  },
  {
    "objectID": "posts/steady-state.html#long-half-life",
    "href": "posts/steady-state.html#long-half-life",
    "title": "Steady State in mrgsolve",
    "section": "5.1 Long half-life",
    "text": "5.1 Long half-life\nSometimes it happens that you have simulated parameters with very long half-life and very long time to steady state, even more than 500 doses. It might happen in 1 or 2 out of 3000 simulated individuals and it will still give the warning. So it might be that you have to set ss_n to something reasonable and also set ss_fixed to true so that you don’t get the warnings."
  },
  {
    "objectID": "posts/steady-state.html#one-compartment-misbehaves",
    "href": "posts/steady-state.html#one-compartment-misbehaves",
    "title": "Steady State in mrgsolve",
    "section": "5.2 One compartment misbehaves",
    "text": "5.2 One compartment misbehaves\nI have seen this with the dosing compartment when there is a very large inter-dose interval. So the amount gets driven very small, maybe flips sign and the calculations for steady state just don’t work out right to call it “good”. Here’s what you can do:\nIn your model, you can now give a vector of compartment to not look at for handling steady state:\n\n[ set ] ss_cmt = \"-DEPOT\"\n\n[ cmt ] DEPOT CENT PERIPH\n\n[ ode ]\ndxdt_DEPOT  = ...;\ndxdt_CENT   = ...;\ndxdt_PERIPH = ...;\n\nThe -DEPOT says “forget about the DEPOT compartment when running up to steady state”; it was giving me numerical problems and I don’t really care about that one so much either."
  },
  {
    "objectID": "posts/steady-state.html#auc-compartment-in-the-model",
    "href": "posts/steady-state.html#auc-compartment-in-the-model",
    "title": "Steady State in mrgsolve",
    "section": "5.3 AUC compartment in the model",
    "text": "5.3 AUC compartment in the model\nLet’s say you’re accumulating stuff in a compartment for AUC calculation. When you have this in the model, you’ll never make it to steady state according to the definition set out above.\n\n[ set ] ss_cmt = \"-AUC\"\n\n[ cmt ] DEPOT CENT PERIPH AUC\n\n[ ode ]\ndxdt_DEPOT  = ...;\ndxdt_CENT   = ...;\ndxdt_PERIPH = ...;\ndxdt_AUC = CENT/V;\n\nRather than trying to figure that out under the hood, mrgsolve just asks you to tell it to forget about the AUC compartment when determining steady state.\nThere is another (better) way to handle this. Users have a new variable that they can check that evaluates to true when mrgsolve is advancing the system to steady state. So you might write this:\n\n[ cmt ] DEPOT CENT PERIPH AUC\n\n[ ode ]\ndxdt_DEPOT  = ...;\ndxdt_CENT   = ...;\ndxdt_PERIPH = ...;\ndxdt_AUC = CENT/V;\n\nif(SS_ADVANCE) dxdt_AUC = 0;\n\nThis will prevent the AUC compartment from advancing at all when mrgsolve is looking for steady state. And this compartment won’t be a stumbling block for the SS determination (as described above)."
  },
  {
    "objectID": "posts/steady-state.html#only-consider-a-single-compartment",
    "href": "posts/steady-state.html#only-consider-a-single-compartment",
    "title": "Steady State in mrgsolve",
    "section": "5.4 Only consider a single compartment",
    "text": "5.4 Only consider a single compartment\nRather than excluding the misbehaving compartment, we can also request that only one compartment be evaluated for SS\n\n[ set ] ss_cmt = \"CENT\"\n\n[ cmt ] DEPOT CENT PERIPH \n\n[ ode ]\ndxdt_DEPOT  = ...;\ndxdt_CENT   = ...;\ndxdt_PERIPH = ...;\n\nThis ignores every compartment except for CENT when figuring out SS."
  },
  {
    "objectID": "posts/new-0-11-0.html",
    "href": "posts/new-0-11-0.html",
    "title": "New in 0.11.0 and 0.11.1",
    "section": "",
    "text": "library(dplyr)\nlibrary(mrgsolve)"
  },
  {
    "objectID": "posts/new-0-11-0.html#see-model-variables",
    "href": "posts/new-0-11-0.html#see-model-variables",
    "title": "New in 0.11.0 and 0.11.1",
    "section": "2.1 See model variables",
    "text": "2.1 See model variables\nWe can now look into the model and see which variables are available to capture. First, coerce mod to a list() and then look at the cpp_variables item:\n\ncpp_variables <- as.list(mod)$cpp_variables\ncpp_variables\n\n    type  var context\n1 define   CP  global\n2 define   CT  global\n3 define CLNL  global\n4 define  INH  global\n\n\nThis tells us what we could capture. Now that we have the information, let’s capture everything possible:\n\nmod <- modlib(\"irm1\", capture = cpp_variables$var)\n\nBuilding irm1 ... done.\n\n\nNow, everything is getting captured:\n\noutvars(mod)\n\n$cmt\n[1] \"EV1\"    \"CENT\"   \"PERIPH\" \"RESP\"   \"EV2\"   \n\n$capture\n[1] \"CP\"   \"CT\"   \"CLNL\" \"INH\" \n\n\nand will appear in the simulated output:\n\nmrgsim(mod, events = ev(amt = 100), param = list(VMAX  = 2))\n\nModel:  irm1 \nDim:    26 x 11 \nTime:   0 to 24 \nID:     1 \n    ID time      EV1  CENT PERIPH  RESP EV2    CP     CT   CLNL    INH\n1:   1    0   0.0000  0.00  0.000 5.000   0 0.000 0.0000 1.0000 0.0000\n2:   1    0 100.0000  0.00  0.000 5.000   0 0.000 0.0000 1.0000 0.0000\n3:   1    1  36.7879 57.40  3.221 2.837   0 2.870 0.3221 0.4107 0.5893\n4:   1    2  13.5335 70.69  8.641 1.988   0 3.534 0.8641 0.3614 0.6386\n5:   1    3   4.9787 69.58 13.484 1.834   0 3.479 1.3484 0.3650 0.6350\n6:   1    4   1.8316 64.48 17.119 1.875   0 3.224 1.7119 0.3828 0.6172\n7:   1    5   0.6738 58.87 19.596 1.970   0 2.943 1.9596 0.4046 0.5954\n8:   1    6   0.2479 53.77 21.135 2.078   0 2.689 2.1135 0.4266 0.5734\n\n\nIn this example, we could choose from a bunch of pre-processor directives, but the only reason for that is this is the way the model was coded. We can look at another example:\n\nmod <- modlib(\"pbpk\")\n\nBuilding pbpk ... done.\n\nas.list(mod)$cpp_variables %>% head()\n\n    type var context\n1 double Vad    main\n2 double Vbo    main\n3 double Vbr    main\n4 double Vgu    main\n5 double Vhe    main\n6 double Vki    main"
  },
  {
    "objectID": "posts/new-0-11-0.html#why-would-i-use-this",
    "href": "posts/new-0-11-0.html#why-would-i-use-this",
    "title": "New in 0.11.0 and 0.11.1",
    "section": "2.2 Why would I use this???",
    "text": "2.2 Why would I use this???\nHere’s an example: I have a covariate model going and I want to get parameter values given some covariates. I can write:\n\nmod <- modlib(\"popex\", capture = \"CL,V,KA\") %>% zero_re()\n\nBuilding popex ... done.\n\nidata <- tibble(WT = seq(40,140,5))\n\nmrgsim(mod, idata = idata, end = -1)\n\nModel:  popex \nDim:    21 x 10 \nTime:   0 to 0 \nID:     21 \n    ID time GUT CENT     CL     V ECL IPRED DV  KA\n1:   1    0   0    0 0.6572 13.71   0     0  0 0.5\n2:   2    0   0    0 0.7179 15.43   0     0  0 0.5\n3:   3    0   0    0 0.7770 17.14   0     0  0 0.5\n4:   4    0   0    0 0.8345 18.86   0     0  0 0.5\n5:   5    0   0    0 0.8908 20.57   0     0  0 0.5\n6:   6    0   0    0 0.9459 22.29   0     0  0 0.5\n7:   7    0   0    0 1.0000 24.00   0     0  0 0.5\n8:   8    0   0    0 1.0531 25.71   0     0  0 0.5\n\n\nNow, I have CL, V and KA all calculated as a function of WT."
  },
  {
    "objectID": "posts/new-0-11-0.html#root-path",
    "href": "posts/new-0-11-0.html#root-path",
    "title": "New in 0.11.0 and 0.11.1",
    "section": "4.1 Root path",
    "text": "4.1 Root path\nThe current default behavior is to interpret the path relative to the current working directory:\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\n\nThis is equivalent to invoking the new root argument and setting it to \"working\":\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\nroot = \"working\"\n\nI am encouraging you to start setting this root argument to \"cppfile\" which tells mrgsolve to interpret the path relative to wherever the model code is located:\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\nroot = \"cppfile\"\n\nWhen you do this, you can load this model from any working directory as long as the file remains in the same location. I am encouraging you to start using this because I think we will eventually make \"cppfile\" the default root because it makes so much more sense.\nNote that you can always specify an absolute path here and in that case, it doesn’t matter what you use for the root argument (see the discussion on here() in the following section).\nWith here()\nSome are also using the here::here() function. This is totally independent of any mrgsolve functionality, but here() will return the absolute path relative to your Rstudio project root. So, if all my models were in the model/nonmem directory, I can always get the absolute path using here() regardless of the working directory and regardless of where the cpp file is located.\n\n[ nmext ] \nrun = 1001\nproject = here::here(\"model/nonmem\")\n\nNote here that the argument / options here are evaluated by the R interpreter so that the here() call resolves to the correct project directory."
  },
  {
    "objectID": "posts/new-0-11-0.html#select-table-number-in-nmext",
    "href": "posts/new-0-11-0.html#select-table-number-in-nmext",
    "title": "New in 0.11.0 and 0.11.1",
    "section": "4.2 Select table number in NMEXT",
    "text": "4.2 Select table number in NMEXT\nThe [ nmext ] block gains an index argument that will let you select which table in the .ext file to import from when there are multiple.\n\nthe default is last\notherwise, pass an integer (e.g. 1 for first, 3 for 3rd)\nsee the ?nmext help topic for more info on this and other argument / options for the nmxml block\n\nTo select the 2nd table:\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\nroot = \"cppfile\"\nindex = 2 \n\nThe default is to select the last table:\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\nroot = \"cppfile\"\nindex = \"last\" // \"first\""
  },
  {
    "objectID": "posts/new-0-11-0.html#reveal-results-file",
    "href": "posts/new-0-11-0.html#reveal-results-file",
    "title": "New in 0.11.0 and 0.11.1",
    "section": "4.3 Reveal results file",
    "text": "4.3 Reveal results file\nWhen you import nonmem results from an .ext file (via [nmext]) or an .xml file (via [nmxml]), the source file is now saved in the model object so that it can be checked later.\nThe internal model library contains an embedded nonmem run numbered 1005; this run imports THETA, OMEGA and SIGMA from a finished nonmem run. You can load this model with the modlib() function.\n\nmod <- modlib(\"1005\")\n\nLoading required namespace: xml2\n\n\nBuilding 1005 ... done.\n\n\nBy coercing the model to list and checking the nm_import item, you’ll get a character vector with the full (absolute) path to either the .ext or .xml file that was imported from\n\nas.list(mod)$nm_import\n\n[1] \"/Users/kyleb/Rlibs/mrgsolve/nonmem/1005/1005.xml\""
  },
  {
    "objectID": "posts/2018-modeled-interventions.html",
    "href": "posts/2018-modeled-interventions.html",
    "title": "Modeled interventions in mrgsolve",
    "section": "",
    "text": "1 Introduction\nThis post is to introduce modeled interventions in mrgsolve. The main use case is to force mrgsolve to advance the system to a specific time so that some aspect of the system can change at that time. This is similar to the MTIME functionality that NONMEM provides. Doses (bolus or infusions) can also be implemented as a modeled event. These events are “modeled” because they originate from code in the $MAIN block, not the input data set, so that the events can be reactive to model parameters or the state of the model itself.\n\n\n2 Status\nAt the time of this post, this functionality is only in a development branch on the mrgsolve GitHub. But we’ve been working on and revising this concept for a while now, so hopefully it is more or less stable with a reasonable interface. That said, specifics or syntax may change before this gets rolled out to CRAN.\n\n\n3 Example: time-varying KA\nOne common use case for modeled events are a time-varying model parameter such as an absorption rate constant. The model with constant KA looks like this\n\ncode <- '\n$PARAM CL = 1, V = 20, KA1 = 0.1, KA2 = 0.5, KA3 = 5\n\n$PKMODEL cmt = \"GUT CENT\", depot = TRUE\n\n$PREAMBLE capture KA = KA1;\n\n$MAIN\nKA = KA2;\n' \n\n\nlibrary(mrgsolve)\n\nmcode_cache(\"mevent0\", code) %>% \n  ev(amt = 100) %>% \n  mrgsim(end = 24, delta = 0.1) %>%\n  plot(CENT+KA~time)\n\n\n\n\nFor the model with time-varying parameter, we want KA to start with a lower value at the time of the oral dose and then increase at some time after the dose. And we want that to happen for every dose. We model the time after the dose when we want KA to change and force the simulation to stop at that time so we can make the required changes.\nThe model with time-varying KA might look like this\n\ncode <- '\n$PARAM CL = 1, V = 20, KA1 = 0.1, KA2 = 0.5, KA3 = 5\n\n$PKMODEL cmt = \"GUT CENT\", depot = TRUE\n\n$MAIN\n\nif(NEWIND <=1) capture KA = KA1;\n\nif(EVID==1) {\n  KA = KA1;\n  self.mevent(TIME + 2, 33);\n}\n\nif(EVID==33) KA = KA3;\n\n' \n\nThe arguments for self.mevent() in this case are:\n\ntime\nevid\n\nWhenever we see a dose (EVID==1), we set KA to the initial (slower) KA value and register a model event that in this case happens two hours later. We use EVID=33 for that change point event. This is a arbitrary choice for EVID (it could be [almost] anything). The idea here is that, when we see EVID==33 come along, we change the KA to the faster value.\nWe don’t have plans to offer indicators like MPAST or MTDIFF as NONMEM does. But we can achieve similar behavior by tagging the event and then looking for that tag again down the road.\nThe simulation looks like this\n\nmod <- mcode_cache(\"mevent\", code)\n\nBuilding mevent ... done.\n\nmod %>% \n  ev(amt = 100) %>% \n  mrgsim(end = 24, delta = 0.1) %>%\n  plot(CENT+KA~time)\n\n\n\n\nWe can refine this even more with an additional intervention time for an intermediate value so that KA changes twice as the dose is absorbed\n\ncode <- '\n$PARAM CL = 1, V = 20, KA1 = 0.1, KA2 = 0.5, KA3 = 5\n\n$PKMODEL cmt = \"GUT CENT\", depot = TRUE\n\n$PREAMBLE capture KA = KA1;\n\n$MAIN\n\nif(EVID==1) {\n  KA = KA1;\n  self.mevent(TIME + 1, 33);\n  self.mevent(TIME + 2, 34);\n}\n\nif(EVID==33) KA = KA2;\nif(EVID==34) KA = KA3;\n\n' \n\nWe use a separate EVID (34) here to distinguish the second change from the first change (with EVID 33).\n\nmod <- mcode_cache(\"mevent2\", code)\n\nBuilding mevent2 ... done.\n\nmod %>% \n  ev(amt = 100) %>% \n  mrgsim(end = 8, delta = 0.1) %>%\n  plot(CENT+KA~time)\n\n\n\n\nNow we have the two change points implemented.\nMultiple doses would look like this\n\nmod %>% \n  ev(amt = 100, ii = 24, addl = 2) %>% \n  mrgsim(end = 120, delta = 0.1) %>%\n  plot(CENT+KA~time)\n\n\n\n\nAnd we can model this so that the change point is a function of a model parameter\n\ncode <- '\n$PARAM CL = 1, V = 20, KA1 = 0.1, KA2 = 0.5, KA3 = 5\nMTIME1 = 2\n\n\n$PKMODEL cmt = \"GUT CENT\", depot = TRUE\n\n$PREAMBLE capture KA = KA1;\n\n$MAIN\n\nif(EVID==1) {\n  KA = KA1;\n  self.mevent(TIME + MTIME1, 33);\n}\n\nif(EVID==33) KA = KA3;\n\n' \n\n\nmod <- mcode_cache(\"mevent3\", code)\n\nBuilding mevent3 ... done.\n\nidata <- data.frame(MTIME1 = seq(0,2.5,0.5))\n\nmod %>% \n  ev(amt = 100) %>% \n  idata_set(idata) %>%\n  mrgsim(end = 8, delta = 0.1) %>%\n  plot(CENT+KA~time)\n\n\n\n\n\n\n4 Example: modeled dosing events\nIn the previous example, we used the mevent call to to force the simulation to stop at the time we wanted a model parameter to change. This was accomplished by an event object with EVID=2, which forces the solver to stop, reset, and then keep going with the new model parameters.\nWe can also use this event mechanism to implement actual doses. Now at the change point, we add some mass to one of the compartments. An example model for q12 hour dosing might look like:\n\ncode <- '\n$PARAM CL = 1, V = 20, KA = 2\n\n$PKMODEL cmt = \"GUT CENT\", depot = TRUE\n\n$MAIN\n\nif(TIME/12 ==floor(TIME/12) && TIME < 120) {\n  mrg::evdata ev(TIME,1);\n  ev.cmt = 1;\n  ev.amt = 100; \n  self.mevector.push_back(ev);\n}\n\n' \n\n\nmod <- mcode_cache(\"mevent4\", code)\n\nBuilding mevent4 ... done.\n\nmod %>%  mrgsim(end = 240, delta = 0.2) %>% plot(CENT~time)\n\n\n\n\nSo here, we simulated without the data set and implemented the dosing from within the model. This isn’t the way you should be implementing dosing like this on a regular basis, but it shows how you can trigger doses from within the model based on what has gone on up to that point in the simulation."
  },
  {
    "objectID": "posts/map_bayes_example.html",
    "href": "posts/map_bayes_example.html",
    "title": "MAP Bayes example",
    "section": "",
    "text": "This is a shortened version of map_bayes.html, showing only the estimation step."
  },
  {
    "objectID": "posts/map_bayes_example.html#what-is-this-function-doing",
    "href": "posts/map_bayes_example.html#what-is-this-function-doing",
    "title": "MAP Bayes example",
    "section": "2.1 What is this function doing?",
    "text": "2.1 What is this function doing?\n\nget the matrix for residual error\nMake sure eta is a list\nMake sure eta is properly named (i.e. ETA1 and ETA2)\nCopy eta into a matrix that is one row\nUpdate the model object (m) with the current values of ETA1 and ETA2\nSimulate from data set d and save output to out object\nIf we are just requesting predictions (if(pred)) return the simulated data\nThe final lines calculate the EBE objective function; see this paper for reference\nNotice that the function returns a single value (a number); the optimizer will minimize this value\n\n\nmapbayes <- function(eta,d,ycol,m,dvcol=ycol,pred=FALSE) {\n    \n  sig2 <- as.numeric(sigma)\n  eta <- as.list(eta)\n  names(eta) <- names(init)\n  eta_m <- eta %>% unlist %>% matrix(nrow=1)\n  m <-  param(m,eta)\n  out <- mrgsim(m,data=d,output=\"df\")\n  if(pred) return(out)\n  # http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3339294/\n  sig2j <- out[[dvcol]]^2*sig2\n  sqwres <- log(sig2j) + (1/sig2j)*(d[[ycol]] - out[[dvcol]])^2\n  nOn <- diag(eta_m %*% omega.inv %*% t(eta_m))\n  return(sum(sqwres,na.rm=TRUE) + nOn)\n}"
  },
  {
    "objectID": "posts/map_bayes_example.html#initial-estimate",
    "href": "posts/map_bayes_example.html#initial-estimate",
    "title": "MAP Bayes example",
    "section": "2.2 Initial estimate",
    "text": "2.2 Initial estimate\n\nNote again that we are optimizing the etas here\n\n\ninit <- c(ETA1=-0.3, ETA2=0.2)\n\nFit the data\n\nnewuoa is from the nloptr package\nOther optimizers (via optim) could probably also be used\n\nArguments to newuoa\n\nFirst: the initial estimates\nSecond: the function to optimize\nThe other argument are passed to mapbayes\n\n\nfit <- nloptr::newuoa(init,mapbayes,ycol=\"DV\",m=mod,d=data)\n\nHere are the final estimates\n\nfit$par\n\n[1]  0.4995400 -0.3274858"
  },
  {
    "objectID": "posts/events.html",
    "href": "posts/events.html",
    "title": "Work with event objects",
    "section": "",
    "text": "library(mrgsolve)\nlibrary(dplyr)\noptions(mrgsolve.soloc=\"build\")\n\n\n1 Introduction\nEvent objects are simple ways to implement PK dosing events into your model simulation.\n\n\n2 Setup\nLet’s illustrate event objects with a one-compartment, PK model. We read this model from the mrgsolve internal model library.\n\nmod <- mread_cache(\"pk1cmt\", modlib(), end=216, delta=0.1)\n\n\n\n3 Events\nEvents are constructed with the ev function\n\ne <- ev(amt=100, ii=24, addl=6)\n\nThis will implement 100 unit doses every 24 hours for a total of 7 doses.\ne has class ev, but really it is just a data frame\n\ne\n\nEvents:\n  time amt ii addl cmt evid\n1    0 100 24    6   1    1\n\n\n\nas.data.frame(e)\n\n  time amt ii addl cmt evid\n1    0 100 24    6   1    1\n\n\nWe can implement this series of doses by passing e in as the events argument to mrgsim\n\nmod %>% mrgsim(events=e) %>% plot(EV1+CP~time)\n\n\n\n\nThe events can also be implemented with the ev constructor along the simulation pipeline\n\nmod %>%\n  ev(amt=100, ii=24, addl=6) %>%\n  mrgsim %>% \n  plot(CP~time)\n\n\n\n\n\n\n4 Event expectations\n\namt is required\nevid=0 is forbidden\nDefault time is 0\nDefault evid is 1\nDefault cmt is 1\n\nAlso by default, rate, ss and ii are 0.\n\n\n5 Combine events\nmrgsolve has operators defined that allow you to combine events. Let’s first define some event objects.\n\ne1 <- ev(amt=500)\ne2 <- ev(amt=250, ii=24, addl=4)\ne3 <- ev(amt=500, ii=24, addl=0)\ne4 <- ev(amt=250, ii=24, addl=4, time=24)\n\nWe can combine e1 and e3 with a collection operator\n\nc(e1,e4)\n\nEvents:\n  time amt cmt evid ii addl\n1    0 500   1    1  0    0\n2   24 250   1    1 24    4\n\n\nmrgsolve also defines a %then$ operator that lets you execute one event and %then% a second event\n\ne3 %then% e2\n\nEvents:\n  time amt ii addl cmt evid\n1    0 500 24    0   1    1\n2   24 250 24    4   1    1\n\n\nNotice that e3 has both ii and addl defined. This is required for mrgsolve to know when to start e2.\n\n\n6 Combine event objects to create a data set\nWe can take several event objects and combine them into a single simulation data frame with the as_data_set function.\n\ne1 <- ev(amt=100, ii=24, addl=6, ID=1:5)\ne2 <- ev(amt=50,  ii=12, addl=13, ID=1:3)\ne3 <- ev(amt=200, ii=24, addl=2, ID=1:2)\n\nWhen combined into a data set, we get * N=5 IDs receiving 100 mg Q24h x7 * N=3 IDs receiving 50 mg Q12h x 14 * N=2 IDs receiving 200 mg Q48h x 3\n\ndata <- as_data_set(e1,e2,e3)\ndata\n\n   ID time cmt evid amt ii addl\n1   1    0   1    1 100 24    6\n2   2    0   1    1 100 24    6\n3   3    0   1    1 100 24    6\n4   4    0   1    1 100 24    6\n5   5    0   1    1 100 24    6\n6   6    0   1    1  50 12   13\n7   7    0   1    1  50 12   13\n8   8    0   1    1  50 12   13\n9   9    0   1    1 200 24    2\n10 10    0   1    1 200 24    2\n\n\nTo simulate from this data set, we use the data_set function. First, let’s load a population PK model\n\nmod <- mread_cache(\"popex\", modlib())\n\n\nmod %>% data_set(data) %>% mrgsim(end=336) %>% plot(GUT+DV ~  .)"
  },
  {
    "objectID": "posts/2017-input_data_set.html",
    "href": "posts/2017-input_data_set.html",
    "title": "Generating input data sets for mrgsolve",
    "section": "",
    "text": "library(mrgsolve)\nlibrary(dplyr)"
  },
  {
    "objectID": "posts/2017-input_data_set.html#expand.ev",
    "href": "posts/2017-input_data_set.html#expand.ev",
    "title": "Generating input data sets for mrgsolve",
    "section": "2.1 expand.ev",
    "text": "2.1 expand.ev\nexpand.ev is like expand.grid: it creates a single data.frame with all combinations of it’s vector arguments. It’s pretty simple but convenient to have. For example,\n\ndata <- expand.ev(amt=c(100,200,300), ID=1:3)\ndata\n\n  ID time amt cmt evid\n1  1    0 100   1    1\n2  2    0 200   1    1\n3  3    0 300   1    1\n4  4    0 100   1    1\n5  5    0 200   1    1\n6  6    0 300   1    1\n7  7    0 100   1    1\n8  8    0 200   1    1\n9  9    0 300   1    1\n\n\nThis function call gives us 3 individuals at each of 3 doses. The expand.grid nature of expand.ev is what gives us 3x3=9 rows in the data set. Notice that the IDs are now 1 through 9 … expand.ev renumbers IDs so that there is only one dosing event per row and there is on row per ID.\nAlso notice that time defaults to 0, evid defaults to 1, and cmt defaults to 1. So, expand.ev fills in some of the required columns for you.\nLet’s simulate with this data set:\n\nmod <- mrgsolve:::house() %>% Req(CP) \nmod %>% \n  mrgsim(data=data) %>% \n  plot(CP~time|factor(ID),scales=\"same\")"
  },
  {
    "objectID": "posts/2017-input_data_set.html#as_data_set",
    "href": "posts/2017-input_data_set.html#as_data_set",
    "title": "Generating input data sets for mrgsolve",
    "section": "2.2 as_data_set",
    "text": "2.2 as_data_set\nThis function allows you to combine several event objects into a single data sets. An example works best to illustrate.\nFirst, create three event objects. Let’s try one ID at 100 mg, two IDs at 200 mg, and 3 IDs at 300 mg.\n\ne1 <- ev(amt=100, ID=1)\ne2 <- ev(amt=200, ID=1:2)\ne3 <- ev(amt=300, ID=1:3)\n\nThe events are\n\ne1\n\nEvents:\n  ID time amt cmt evid\n1  1    0 100   1    1\n\n\nand\n\ne2\n\nEvents:\n  ID time amt cmt evid\n1  1    0 200   1    1\n2  2    0 200   1    1\n\n\nand\n\ne3\n\nEvents:\n  ID time amt cmt evid\n1  1    0 300   1    1\n2  2    0 300   1    1\n3  3    0 300   1    1\n\n\nWhen we combine these events with as_data_set we get\n\ndata <- as_data_set(e1,e2,e3)\ndata\n\n  ID time cmt evid amt\n1  1    0   1    1 100\n2  2    0   1    1 200\n3  3    0   1    1 200\n4  4    0   1    1 300\n5  5    0   1    1 300\n6  6    0   1    1 300\n\n\nA nice feature of as_data_set is, unlike expand.ev and the previous example, we can use complicated event sequences that are expressed with more than one line in the data set. For example, consider the case where every ID gets a 250 mg loading dose, and then either get 250 mg q24h, or 120 mg q12h or 500 mg q48h.\n\nload <- function(n) ev(amt=250, ID=1:n)\ne1 <- load(1) + ev(amt=250, time=24, ii=24, addl=3, ID=1)\ne2 <- load(2) + ev(amt=125, time=24, ii=12, addl=7, ID=1:2)\ne3 <- load(3) + ev(amt=500, time=24, ii=48, addl=1, ID=1:3)\n\nNow, e1, e2, and e3 are more complex\n\ne1\n\nEvents:\n  ID time amt cmt evid ii addl\n1  1    0 250   1    1  0    0\n2  1   24 250   1    1 24    3\n\ne3\n\nEvents:\n  ID time amt cmt evid ii addl\n1  1    0 250   1    1  0    0\n4  1   24 500   1    1 48    1\n2  2    0 250   1    1  0    0\n5  2   24 500   1    1 48    1\n3  3    0 250   1    1  0    0\n6  3   24 500   1    1 48    1\n\n\nBut, we can still pull them together in one single data set\n\ndata <- as_data_set(e1,e2,e3)\ndata\n\n   ID time cmt evid amt ii addl\n1   1    0   1    1 250  0    0\n2   1   24   1    1 250 24    3\n3   2    0   1    1 250  0    0\n4   2   24   1    1 125 12    7\n5   3    0   1    1 250  0    0\n6   3   24   1    1 125 12    7\n7   4    0   1    1 250  0    0\n8   4   24   1    1 500 48    1\n9   5    0   1    1 250  0    0\n10  5   24   1    1 500 48    1\n11  6    0   1    1 250  0    0\n12  6   24   1    1 500 48    1\n\n\nAn example simulation\n\nset.seed(1112)\nmod %>% \n  omat(dmat(1,1,1,1)/10) %>% \n  data_set(data) %>% \n  mrgsim() %>% \n  plot"
  },
  {
    "objectID": "posts/2017-input_data_set.html#as.data.frame.ev",
    "href": "posts/2017-input_data_set.html#as.data.frame.ev",
    "title": "Generating input data sets for mrgsolve",
    "section": "2.3 as.data.frame.ev",
    "text": "2.3 as.data.frame.ev\nJust a quick reminder here that you can easily convert between a single event object and a data.frame\n\nas.data.frame(e3)\n\n  ID time amt cmt evid ii addl\n1  1    0 250   1    1  0    0\n4  1   24 500   1    1 48    1\n2  2    0 250   1    1  0    0\n5  2   24 500   1    1 48    1\n3  3    0 250   1    1  0    0\n6  3   24 500   1    1 48    1\n\nas.ev(as.data.frame(e3))\n\nEvents:\n  ID time amt ii addl cmt evid\n1  1    0 250  0    0   1    1\n4  1   24 500 48    1   1    1\n2  2    0 250  0    0   1    1\n5  2   24 500 48    1   1    1\n3  3    0 250  0    0   1    1\n6  3   24 500 48    1   1    1\n\n\nSo if you were building up an event object and just wanted to use it as a data_set or as a building block for a data_set, just coerce with as.data.frame."
  },
  {
    "objectID": "posts/2017-input_data_set.html#assign_ev",
    "href": "posts/2017-input_data_set.html#assign_ev",
    "title": "Generating input data sets for mrgsolve",
    "section": "2.4 assign_ev",
    "text": "2.4 assign_ev\nThis function assigns an intervention in the form of an event object to individuals in an idata_set according to a grouping column.\nTo illustrate, make a simple idata_set\n\nset.seed(8)\nidata <- data_frame(ID=sample(1:6), arm=c(1,2,2,3,3,3))\n\nWarning: `data_frame()` was deprecated in tibble 1.1.0.\nℹ Please use `tibble()` instead.\n\nidata\n\n# A tibble: 6 × 2\n     ID   arm\n  <int> <dbl>\n1     4     1\n2     2     2\n3     3     2\n4     6     3\n5     5     3\n6     1     3\n\n\nHere, we have 6 IDs, one in arm 1, two in arm 2, three in arm 3. Let’s take the events from the previous example and assign them to the different arms.\n\ne1 <- ev(amt=250) + ev(amt=250, time=24, ii=24, addl=3)\ne2 <- ev(amt=250) + ev(amt=125, time=24, ii=12, addl=7)\ne3 <- ev(amt=250) + ev(amt=500, time=24, ii=48, addl=1)\nassign_ev(list(e3,e2,e1),idata,\"arm\")\n\n   time amt cmt evid ii addl ID\n1     0 250   1    1  0    0  4\n2    24 500   1    1 48    1  4\n3     0 250   1    1  0    0  2\n4    24 125   1    1 12    7  2\n5     0 250   1    1  0    0  3\n6    24 125   1    1 12    7  3\n7     0 250   1    1  0    0  6\n8    24 250   1    1 24    3  6\n9     0 250   1    1  0    0  5\n10   24 250   1    1 24    3  5\n11    0 250   1    1  0    0  1\n12   24 250   1    1 24    3  1\n\n\nPlease look carefully at the input (idata and list(e3,e2,e1)); I have mixed it up a bit here to try to illustrate how things are assigned."
  },
  {
    "objectID": "posts/2017-input_data_set.html#ev_days",
    "href": "posts/2017-input_data_set.html#ev_days",
    "title": "Generating input data sets for mrgsolve",
    "section": "2.5 ev_days",
    "text": "2.5 ev_days\nThis is a recently-added function (hint: you might need to install the latest version from GitHub to use this) that lets you schedule certain events on certain days of the week, repeating in a weekly cycle.\nFor example, to schedule 250 mg doses every Monday, Wednesday, and Friday for a month, you can do\n\ndata <- ev_days(ev(amt=250, ID=1), days=\"m,w,f\", addl=3)\ndata\n\n  ID time amt cmt evid  ii addl\n1  1    0 250   1    1 168    3\n2  1   48 250   1    1 168    3\n3  1   96 250   1    1 168    3\n\nmod %>% mrgsim(data=data,end=168*4) %>% plot\n\n\n\n\nOr, you can do 100 mg doses on Monday, Wednesday, Friday, and 50 mg doses on Tuesday, Thursday, with drug holiday on weekends\n\ne1 <- ev(amt=100,ID=1)\ne2 <- ev(amt=50,ID=1)\ndata <- ev_days(m=e1,w=e1,f=e1,t=e2,th=e2,addl=3)\ndata\n\n  ID time amt cmt evid  ii addl\n1  1    0 100   1    1 168    3\n2  1   24  50   1    1 168    3\n3  1   48 100   1    1 168    3\n4  1   72  50   1    1 168    3\n5  1   96 100   1    1 168    3\n\n\nAnd simulate\n\nmod %>% mrgsim(data=data,end=168*4) %>% plot\n\n\n\n\nThe same thing can be accomplished like this\n\na <- ev_days(e1,days=\"m,w,f\",addl=3)\nb <- ev_days(e2,days=\"t,th\",addl=3)\n\nc(as.ev(a),as.ev(b))\n\nEvents:\n  ID time amt  ii addl cmt evid\n1  1    0 100 168    3   1    1\n4  1   24  50 168    3   1    1\n2  1   48 100 168    3   1    1\n5  1   72  50 168    3   1    1\n3  1   96 100 168    3   1    1\n\n\nYou can use this as an event object or just coerce to data.frame to use as a data_set."
  },
  {
    "objectID": "posts/2017-mixture-model.html",
    "href": "posts/2017-mixture-model.html",
    "title": "Mixture model example",
    "section": "",
    "text": "In NONMEM, $MIXTURE will allow you to estimate mixture models, where individuals are classified in to two or more populations with a certain probability. It is straightforward to simulate from models like these in your mrgsolve model code."
  },
  {
    "objectID": "posts/2017-mixture-model.html#modify-the-model-to-simulate-a-population-mixture",
    "href": "posts/2017-mixture-model.html#modify-the-model-to-simulate-a-population-mixture",
    "title": "Mixture model example",
    "section": "1.1 Modify the model to simulate a population mixture",
    "text": "1.1 Modify the model to simulate a population mixture\nIn the get-started example model, we hard-coded POP as a parameter and we had to supply the value of POP in the input data set (in this case, it was via idata).\nFor the mixture model, we want POP to be simulated and we want the simulated value to be 1 with a probability of, say, 0.8 and 2 with a probability of 0.2.\nTo make this happen, we need to simulate a binary variate for each individual. Random numbers are easy to simulate with mrgsolve when you use $PLUGIN.\n\ncode <- '\n$PLUGIN Rcpp\n\n$MAIN\nif(NEWIND <=1) {\n  int POP = 1 + R::rbinom(1,0.2);\n}\n\n$CAPTURE POP\n'\n\nmod <- mcode_cache(\"B\", code)\n\nBuilding B ... done.\n\n\nHere, we invoked the Rcpp plugin that allows us to call R::binom(1,0.8). R::binom is just like the regular R version, but it only draws one variate (n=1).\nLet’s test it out\n\nset.seed(222)\nout <- mrgsim(mod, nid=10000, end=-1)\n\nhead(out)\n\n  ID time POP\n1  1    0   2\n2  2    0   1\n3  3    0   1\n4  4    0   1\n5  5    0   2\n6  6    0   2\n\n\nHere, we’ve got 20% of the people in the population with POP of 2:\n\nmean(out$POP==2)\n\n[1] 0.1973\n\n\nNow, let’s modify the model again to incorporate our random POP calculation with the PK model. I have also included a home-brewed ETA using R::rnorm as another example and to make the summary a little more interesting.\n\ncode <- '\n$PLUGIN Rcpp\n\n$PARAM TVCL = 1, V = 30, KA=1.2, THETA1 = 0.5\n\n$PKMODEL cmt=\"GUT CENT\", depot=TRUE\n\n$MAIN\nif(NEWIND <=1) {\n  int POP = 1 + R::rbinom(1,0.2);\n  double myETA = R::rnorm(0,sqrt(0.09));\n}\n\ndouble CL = TVCL;\n\nif(POP==2) CL = TVCL * THETA1;\n\ndouble CLi = CL*exp(myETA);\n\n$CAPTURE POP CL CLi\n'\n\nmod <- mcode_cache(\"C\", code)\n\nBuilding C ... done.\n\n\nAnd simulate again\n\nset.seed(444)\nout <- mrgsim(mod,nid=10000, end=72, events=e,obsonly=TRUE)\n\n\nhead(out)\n\n  ID time        GUT     CENT POP CL       CLi\n1  1    0  0.0000000  0.00000   1  1 0.7642753\n2  1    1 30.1194212 68.50511   1  1 0.7642753\n3  1    2  9.0717953 86.89259   1  1 0.7642753\n4  1    3  2.7323722 90.25855   1  1 0.7642753\n5  1    4  0.8229747 89.17134   1  1 0.7642753\n6  1    5  0.2478752 86.81173   1  1 0.7642753\n\nmean(out$CL==0.5)\n\n[1] 0.1977\n\n\n\nout %>% \n  filter(time==0) %>%\n  group_by(POP) %>% \n  summarise(N=n(), Median = median(CLi))\n\n# A tibble: 2 × 3\n    POP     N Median\n  <dbl> <int>  <dbl>\n1     1  8023  1.00 \n2     2  1977  0.499"
  },
  {
    "objectID": "posts/2019-ev_rx.html",
    "href": "posts/2019-ev_rx.html",
    "title": "Alternate dosing event syntax",
    "section": "",
    "text": "library(mrgsolve)\nlibrary(dplyr)\noptions(mrgsolve.soloc=\"build\")\nI got into pharmacometrics after studying and working as a pharmacist, both in a community pharmacy (interning while I was a pharmacy student) and in an inpatient (hospital) pharmacy (practicing as a pharmacist while studying pharmacometrics and clinical pharmacology). So I always thought it would be cool to have mrgsolve take in dosing information like you would see on a Rx or written in a chart\nThis post introduces something new in mrgsolve 0.9.0 that works along those lines."
  },
  {
    "objectID": "posts/2019-ev_rx.html#bolus-doses",
    "href": "posts/2019-ev_rx.html#bolus-doses",
    "title": "Alternate dosing event syntax",
    "section": "2.1 Bolus doses",
    "text": "2.1 Bolus doses\n\ne5 <- ev_rx(\"100 q 24 x7 then 100 q48 x 4\")\n\ne5\n\nEvents:\n  time amt ii addl cmt evid\n1    0 100 24    6   1    1\n2  168 100 48    3   1    1\n\n\n\nmrgsim_e(mod, e5, end = 168*3) %>% plot()\n\n\n\n\nThe syntax is:\n\nStart with amt\nDosing interval follows q\nTotal number of doses follows x\nA second part of the sequence follows then"
  },
  {
    "objectID": "posts/2019-ev_rx.html#infusion",
    "href": "posts/2019-ev_rx.html#infusion",
    "title": "Alternate dosing event syntax",
    "section": "2.2 Infusion",
    "text": "2.2 Infusion\nTo do an infusion, the duration of the infusion comes after over\n\ne6 <- ev_rx(\"100 over 10 q 48 x 3\")\n\ne6\n\nEvents:\n  time amt rate ii addl cmt evid\n1    0 100   10 48    2   1    1\n\nmrgsim_e(mod, e6, end = 168) %>% plot()\n\n\n\n\nHrm … but we wanted the infusion to be IV, not in the depot compartment. To do that, put the compartment number after in\n\ne7 <- ev_rx(\"100 over 10 in 2 q 48 x 3\")\n\ne7\n\nEvents:\n  time amt rate ii addl cmt evid\n1    0 100   10 48    2   2    1\n\nmrgsim_e(mod,e7, end = 168) %>% plot()"
  },
  {
    "objectID": "posts/2019-ev_rx.html#another-sequence",
    "href": "posts/2019-ev_rx.html#another-sequence",
    "title": "Alternate dosing event syntax",
    "section": "2.3 Another sequence",
    "text": "2.3 Another sequence\nRather than then you can separate by comma. Also, see if you can tell what after does here:\n\ne <- ev_rx(\"100 q 24 x 7, 50 q 12 x 14, 200 q48 x 3 after 72\")\n\ne\n\nEvents:\n  time amt ii addl cmt evid\n1    0 100 24    6   1    1\n2  168  50 12   13   1    1\n3  408 200 48    2   1    1\n\n\nIt still takes a fair amount of text to get all of this out, but hopefully the notation is relatively compact and expressive.\n\nmrgsim_e(mod, e, end = 600) %>% plot()"
  },
  {
    "objectID": "posts/2022-05-validate-translation/index.html",
    "href": "posts/2022-05-validate-translation/index.html",
    "title": "Validate model translation from NONMEM",
    "section": "",
    "text": "We frequently use mrgsolve to simulate from models estimated in NONMEM. This requires translation of the model from the NONMEM control stream into mrgsolve format.\nThere is a straightforward way to confirm correct coding of the mrgsolve model once the NONMEM model is in hand. This blog post will show you how to do that.\n\n\n\n\n\n\nExpand view packages and options\n\n\n\n\n\n\nlibrary(mrgsolve)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(data.table)\nlibrary(here)\noptions(bbr.verbose = TRUE, mrgsolve.project = here(\"model/pk\"))"
  },
  {
    "objectID": "posts/2022-05-validate-translation/index.html#bbrnm_join",
    "href": "posts/2022-05-validate-translation/index.html#bbrnm_join",
    "title": "Validate model translation from NONMEM",
    "section": "2.1 bbr::nm_join",
    "text": "2.1 bbr::nm_join\n\n\n\n\n\n\nIf you are using bbr as your modeling platform, you can get the same data set with a one-liner call to bbr::nm_join()\n\ndata <- bbr::nm_join(here(\"model/pk/106\"))"
  },
  {
    "objectID": "posts/init.html",
    "href": "posts/init.html",
    "title": "Set initial conditions",
    "section": "",
    "text": "There are several ways to set initial conditions in mrgsolve. Find out how this can work to your advantage when planning your simulations."
  },
  {
    "objectID": "posts/init.html#set-initials-in-main",
    "href": "posts/init.html#set-initials-in-main",
    "title": "Set initial conditions",
    "section": "1.1 Set initials in $MAIN",
    "text": "1.1 Set initials in $MAIN\nFor a compartment called CMT, there is a variable available to you called CMT_0 that you can use to set the initial condition of that compartment in $MAIN. For example:\n\ncode <- '\n$PARAM KIN = 200, KOUT = 50\n\n$CMT RESP\n\n$MAIN\nRESP_0 = KIN/KOUT;\n'\n\nThis is the most commonly-used way to set initial conditions: the initial condition for the RESP compartment is set equal to KIN divided by KOUT. If you had a parameter called BASE, you could also write RESP_0 = BASE;. In these examples, we’re using data items from $PARAM. But the initial condition could be set to any numeric value in the model, including individual parameters derived from parameters, covariates, and random effects. Note that you should never declare RESP_0 (e.g. double RESP_0): it just appears for you to use."
  },
  {
    "objectID": "posts/init.html#set-initials-in-the-init-list",
    "href": "posts/init.html#set-initials-in-the-init-list",
    "title": "Set initial conditions",
    "section": "1.2 Set initials in the init list",
    "text": "1.2 Set initials in the init list\nYou can also set initial conditions in the initials list. Most commonly, this means declaring compartments with $INIT rather than $CMT. For example\n\ncode <- '\n$INIT RESP = 4\n'\n\nThis method gets us the same result as the previous example, however the initial condition now is not a derived value, but it is coded as a number. Alternatively, you could declare a compartment via $CMT and update later (see next).\nWe can update this value later like this\n\nmod <- mcode_cache(\"init_up\", code)\n\nLoading model from cache.\n\ninit(mod)\n\n\n Model initial conditions (N=1):\n name       value . name    value\n RESP (1)   4     | . ...   .    \n\ninit(mod, RESP=8) %>% init\n\n\n Model initial conditions (N=1):\n name       value . name    value\n RESP (1)   8     | . ...   .    \n\n\nThis method is commonly used to set initial conditions in large QSP models where the compartment starts out as some known or assumed steady state value."
  },
  {
    "objectID": "posts/init.html#dont-use-initial-conditions-as-a-dosing-mechanism",
    "href": "posts/init.html#dont-use-initial-conditions-as-a-dosing-mechanism",
    "title": "Set initial conditions",
    "section": "1.3 Don’t use initial conditions as a dosing mechanism",
    "text": "1.3 Don’t use initial conditions as a dosing mechanism\nUsing an initial condition to put a starting dose in a compartment is not recommended. Always use a dosing event for that."
  },
  {
    "objectID": "posts/init.html#make-a-model-only-to-examine-init-behavior",
    "href": "posts/init.html#make-a-model-only-to-examine-init-behavior",
    "title": "Set initial conditions",
    "section": "2.1 Make a model only to examine init behavior",
    "text": "2.1 Make a model only to examine init behavior\nNote: IFLAG is my invention only for this demo. The demo is always responsible for setting and interpreting the value (it is not reserved in any way and mrgsolve does not control the value).\nFor this demo\n\nCompartment A initial condition defaults to 0\nCompartment A initial condition will get set to BASE only if IFLAG  > 0\nCompartment A always stays at the initial condition (the system doesn’t advance)\n\n\ncode <- '\n$PARAM BASE=200, IFLAG = 0\n\n$CMT A\n\n$MAIN\nif(IFLAG > 0) A_0 = BASE;\n\n$ODE dxdt_A = 0;\n'\n\n\nmod <- mcode_cache(\"init_long\",code)\n\nLoading model from cache.\n\ndplot <- function(x) plot(x,ylim=c(0,400))\n\nCheck the initial condition\n\ninit(mod)\n\n\n Model initial conditions (N=1):\n name    value . name    value\n A (1)   0     | . ...   .    \n\n\nNote:\n\nWe used $CMT in the model spec; that implies that the base initial condition for A is set to 0\nIn this chunk, the code in $MAIN doesn’t get run because IFLAG is 0\nSo, if we don’t update something in $MAIN the initial condition is as we set it in the base list\n\n\nmod %>% mrgsim %>% dplot\n\n\n\n\nNext, we update the base initial condition for A to 100\nNote:\n\nThe code in $MAIN still doesn’t get run because IFLAG is 0\n\n\nmod %>% init(A = 100) %>% mrgsim %>% dplot\n\n\n\n\nNow, turn on IFLAG\nNote:\n\nNow, that code in $MAIN gets run\nA_0 is set to the value of BASE\n\n\nmod %>% param(IFLAG=1) %>% mrgsim %>% dplot\n\n\n\nmod %>% param(IFLAG=1, BASE=300) %>% mrgsim %>% dplot"
  },
  {
    "objectID": "posts/init.html#example-pkpd-model-with-initial-condition",
    "href": "posts/init.html#example-pkpd-model-with-initial-condition",
    "title": "Set initial conditions",
    "section": "2.2 Example PK/PD model with initial condition",
    "text": "2.2 Example PK/PD model with initial condition\nJust to be clear, there is no need to set any sort of flag to set the initial condition.\n\ncode <- '\n$PARAM AUC=0, AUC50 = 75, KIN=200, KOUT=5\n\n$CMT RESP\n\n$MAIN \nRESP_0 = KIN/KOUT;\n\n$ODE\ndxdt_RESP = KIN*(1-AUC/(AUC50+AUC)) - KOUT*RESP;\n'\n\n\nmod <- mcode_cache(\"init_long2\", code)\n\nLoading model from cache.\n\n\nThe initial condition is set to 40 per the values of KIN and KOUT\n\nmod %>% mrgsim %>% plot\n\n\n\n\nEven when we change RESP_0 in R, the calculation in $MAIN gets the final say\n\nmod %>% init(RESP=1E9) %>% mrgsim\n\nModel:  init_long2 \nDim:    25 x 3 \nTime:   0 to 24 \nID:     1 \n    ID time RESP\n1:   1    0   40\n2:   1    1   40\n3:   1    2   40\n4:   1    3   40\n5:   1    4   40\n6:   1    5   40\n7:   1    6   40\n8:   1    7   40"
  },
  {
    "objectID": "posts/init.html#calling-init-will-let-you-check-to-see-what-is-going-on",
    "href": "posts/init.html#calling-init-will-let-you-check-to-see-what-is-going-on",
    "title": "Set initial conditions",
    "section": "2.3 Calling init will let you check to see what is going on",
    "text": "2.3 Calling init will let you check to see what is going on\n\nIt’s a good idea to get in the habit of doing this when things aren’t clear\ninit first takes the base initial condition list, then calls $MAIN and does any calculation you have in there; so the result is the calculated initials\n\n\ninit(mod)\n\n\n Model initial conditions (N=1):\n name       value . name    value\n RESP (1)   40    | . ...   .    \n\nmod %>% param(KIN=100) %>% init\n\n\n Model initial conditions (N=1):\n name       value . name    value\n RESP (1)   20    | . ...   ."
  },
  {
    "objectID": "posts/validation_pmxtools.html",
    "href": "posts/validation_pmxtools.html",
    "title": "Validating Simulation Results with pmxTools",
    "section": "",
    "text": "I just discovered this nifty tool published by the folks over at Occams (with other contributors as well) called pmxTools. There are a lot of really useful R functions for your pharmacometrics workflow in this package and worth checking it out in depth!\nWhat I want to focus on for this post is how we can use this package to cross validate mrgsolve output: we’ll simulate with pmxTools and mrgsolve just to see the different workflows and check the output values. If users are interested in other validation tests for mrgsolve, please see the document here. This is not a “lets-go-head-to-head with another project” type post. I just found this tool very useful as a complement to my workflow. I hope you find it useful too."
  },
  {
    "objectID": "posts/validation_pmxtools.html#simulate-with-pmxtoolspk_curve",
    "href": "posts/validation_pmxtools.html#simulate-with-pmxtoolspk_curve",
    "title": "Validating Simulation Results with pmxTools",
    "section": "2.1 Simulate with pmxTools::pk_curve",
    "text": "2.1 Simulate with pmxTools::pk_curve\nYou can use this function to generate a PK profile based on super-positioning.\nTo simulate a 2-compartment model after IV infusion of 100 mg over 10 hours, first define a list of pk parameters, including tinf, the infusion duration\n\npars <- list(CL = 1, V1 = 4, V2 = 50, Q = 5, tinf=10)\n\nCall pk_curve and provide simulation times, dose regimen (including dose, ii, addl), the model parameters, and select the model, in this case it is 2cmt_infusion\n\ncalc <- pk_curve(\n  t = seq(0,400,0.1), \n  dose = 100, \n  ii = 24, \n  addl = 9, \n  params = pars, \n  model=\"2cmt_infusion\"\n)\n\n\nhead(calc)\n\n    t        cp\n1 0.0 0.0000000\n2 0.1 0.2322016\n3 0.2 0.4323273\n4 0.3 0.6050735\n5 0.4 0.7544486\n6 0.5 0.8838735\n\n\n\nggplot(data = calc, aes(t,cp)) + geom_line() + theme_bw()\n\n\n\n\nPretty easy!"
  },
  {
    "objectID": "posts/validation_pmxtools.html#simulate-with-mrgsolve",
    "href": "posts/validation_pmxtools.html#simulate-with-mrgsolve",
    "title": "Validating Simulation Results with pmxTools",
    "section": "2.2 Simulate with mrgsolve",
    "text": "2.2 Simulate with mrgsolve\nWe can load the 2-compartment model from our model library, and update the parameter set. We make an event object with the dosing information and simulate:\n\nmod <- \n  modlib(\"pk2\", delta = 0.1, end = 400) %>% \n  param(CL = 1, V2 = 4, V3 = 50, Q = 5)\n\nLoading model from cache.\n\ne <- ev(amt = 100, rate = 10, ii = 24, addl = 9, cmt = 2)\n\nout <- mrgsim_e(mod,e, obsonly=TRUE, recsort=3)\n\n\nplot(out, CP~time)\n\n\n\nhead(out)\n\n  ID time EV      CENT     PERIPH        CP\n1  1  0.0  0 0.0000000 0.00000000 0.0000000\n2  1  0.1  0 0.9288064 0.05929462 0.2322016\n3  1  0.2  0 1.7293093 0.22531873 0.4323273\n4  1  0.3  0 2.4202941 0.48225334 0.6050735\n5  1  0.4  0 3.0177942 0.81659743 0.7544486\n6  1  0.5  0 3.5354939 1.21682828 0.8838735"
  },
  {
    "objectID": "posts/validation_pmxtools.html#are-they-the-same",
    "href": "posts/validation_pmxtools.html#are-they-the-same",
    "title": "Validating Simulation Results with pmxTools",
    "section": "2.3 Are they the same?",
    "text": "2.3 Are they the same?\nWe can check the difference between the values:\n\nsummary(out$CP-calc[[\"cp\"]])\n\n      Min.    1st Qu.     Median       Mean    3rd Qu.       Max. \n-7.550e-14 -2.487e-14 -1.021e-14  2.443e-15  4.091e-14  5.751e-14"
  },
  {
    "objectID": "posts/new-0-10-7.html",
    "href": "posts/new-0-10-7.html",
    "title": "New in 0.10.7",
    "section": "",
    "text": "library(tidyverse)\nlibrary(mrgsolve)\n\n\n1 Introduction\nThis blog post shows some of the new features that came into mrgsolve starting with version 0.10.7 (December 2020). The purpose is to illustrate what is possible rather than detailed documentation. There were other small bugs and gremlins fixed as well, but we are focused on bigger, user-facing changes here.\n\n\n2 Specify capture at compile time\nBig Idea: The feature helps give you more flexibility for getting data out of your model and into your simulated output. You have the ability to select output items when you run mread() in addition to specifying them in the model code.\nIn your mrgsolve model, you can request that the values of different variables are written into the simulated output. This is done through the capture block or by declaring variables as type capture\n\nmod <- mread(\"popexample.mod\")\n\nBuilding popexample_mod ... done.\n\nblocks(mod, MAIN, TABLE, CAPTURE)\n\n\nModel file: popexample.mod \n\n$MAIN\ndouble CL = exp(log(TVCL) + 0.75*log(WT/70) + ECL);\ndouble V  = exp(log(TVV)  +      log(WT/70) + EV );\ndouble KA = exp(log(TVKA)                   + EKA);\n\n$TABLE\ndouble IPRED = CENT/V;\ncapture DV = IPRED*exp(EPS(1));\n\n$CAPTURE\nCL\n\n\nHere we have derived several variables (CL, V, KA, IPRED, DV) and some of them have been marked for “capture” (DV and CL).\nWe can check what will be captured\n\noutvars(mod)\n\n$cmt\n[1] \"GUT\"  \"CENT\"\n\n$capture\n[1] \"CL\" \"DV\"\n\n\nStarting with mrgsolve 0.10.7, you can specify additional variables for capture when you read in the model with mread()\n\nmod <- mread(\"popexample.mod\", capture = \"ETA(1), WT, IPRED, V\")\n\nBuilding popexample_mod ... (waiting) ...\ndone.\n\n\nHere, I’ve asked for the value of one of the ETAs, a parameter (WT) and a couple of derived quantities (IPRED and V)\n\noutvars(mod)\n\n$cmt\n[1] \"GUT\"  \"CENT\"\n\n$capture\n[1] \"CL\"    \"DV\"    \"ETA_1\" \"WT\"    \"IPRED\" \"V\"    \n\n\nAnd now when I simulate from the model, I’ll get all of these quantities back\n\nmrgsim(mod, ev(amt = 100))\n\nModel:  popexample_mod \nDim:    482 x 10 \nTime:   0 to 240 \nID:     1 \n    ID time    GUT  CENT    CL    DV ETA_1 WT IPRED V\n1:   1  0.0   0.00  0.00 1.057 0.000     0  0     0 0\n2:   1  0.0 100.00  0.00 1.057 0.000     0  0     0 0\n3:   1  0.5  83.53 16.28 1.057 0.675     0  0     0 0\n4:   1  1.0  69.77 29.53 1.057 1.224     0  0     0 0\n5:   1  1.5  58.28 40.26 1.057 1.669     0  0     0 0\n6:   1  2.0  48.69 48.88 1.057 2.026     0  0     0 0\n7:   1  2.5  40.67 55.74 1.057 2.311     0  0     0 0\n8:   1  3.0  33.97 61.16 1.057 2.535     0  0     0 0\n\n\nThis is temporary until the model is re-compiled again\n\nmread(\"popexample.mod\") %>% outvars\n\nBuilding popexample_mod ... done.\n\n\n$cmt\n[1] \"GUT\"  \"CENT\"\n\n$capture\n[1] \"CL\" \"DV\"\n\n\n\n\n3 Smarter warnings when non-numeric columns are dropped\nmrgsolve warns you when non-numeric columns are dropped from the data set when you run the model. For example\n\nmod <- modlib(\"popex\") %>% update(outvars = \"IPRED\")\n\nIn this model, we have the following parameters\n\nparam(mod)\n\n\n Model parameters (N=4):\n name value . name value\n TVCL 1     | TVV  24   \n TVKA 0.5   | WT   70   \n\n\nLet’s create an input data set with some character values: two parameter columns and one non-parameter column\n\ndata <- expand.ev(amt = 100, WT = \"500\", TVV = \"ABC\", name = \"KYLE\")\n\nWhen we simulation, we get some messages for dropped columns\n\nmrgsim(mod, data)\n\n[data-set] dropped column: WT (character)\n\n\n[data-set] dropped column: TVV (character)\n\n\nModel:  popex \nDim:    482 x 3 \nTime:   0 to 240 \nID:     1 \n    ID time  IPRED\n1:   1  0.0 0.0000\n2:   1  0.0 0.0000\n3:   1  0.5 0.4051\n4:   1  1.0 0.7667\n5:   1  1.5 1.0887\n6:   1  2.0 1.3745\n7:   1  2.5 1.6272\n8:   1  3.0 1.8498\n\n\nPreviously, mrgsolve would have warned you about all 3 columns; now it only warns you about columns that are dropped and would have been relevant to the simulation.\nThis example is made up to illustrate the behavior. But in typical usage when we do things right, we might have extra character columns that we don’t care about. In this case we get no warnings:\n\ndata <- expand.ev(\n  amt = 100, WT = 70, TVV = 20, \n  name = \"KYLE\", \n  state = \"minnesota\"\n)\n\nmrgsim(mod, data)\n\nModel:  popex \nDim:    482 x 3 \nTime:   0 to 240 \nID:     1 \n    ID time IPRED\n1:   1  0.0 0.000\n2:   1  0.0 0.000\n3:   1  0.5 1.215\n4:   1  1.0 2.020\n5:   1  1.5 2.547\n6:   1  2.0 2.882\n7:   1  2.5 3.087\n8:   1  3.0 3.204\n\n\nRemember, we can still ask for non-numeric items to be brought into the data set with the recover argument\n\nmrgsim(mod, data, recover = \"name,state\")\n\nModel:  popex \nDim:    482 x 5 \nTime:   0 to 240 \nID:     1 \n    ID time IPRED name     state\n1:   1  0.0 0.000 KYLE minnesota\n2:   1  0.0 0.000 KYLE minnesota\n3:   1  0.5 3.058 KYLE minnesota\n4:   1  1.0 4.876 KYLE minnesota\n5:   1  1.5 5.923 KYLE minnesota\n6:   1  2.0 6.493 KYLE minnesota\n7:   1  2.5 6.767 KYLE minnesota\n8:   1  3.0 6.859 KYLE minnesota\n\n\n\n\n4 $ERROR\nThere is a new block alias called $ERROR that is just an alias for $TABLE\n\ncode <- '\n$PARAM CL = 1, V = 20, KA = 1\n\n$PKMODEL cmt = \"CENT\"\n\n$ERROR\ncapture CP = CENT/V;\n'\nmod <- mcode(\"error\", code)\n\nBuilding error ... done.\n\nmrgsim(mod, ev(amt = 100))\n\nModel:  error \nDim:    26 x 4 \nTime:   0 to 24 \nID:     1 \n    ID time   CENT    CP\n1:   1    0   0.00 0.000\n2:   1    0 100.00 5.000\n3:   1    1  95.12 4.756\n4:   1    2  90.48 4.524\n5:   1    3  86.07 4.304\n6:   1    4  81.87 4.094\n7:   1    5  77.88 3.894\n8:   1    6  74.08 3.704\n\n\n\n\n5 Try loading the model at runtime if it isn’t loaded\nSometimes, you find yourself with a model object but the shared object hasn’t been loaded into the session. This could happen when you are running simulations in parallel and the model doesn’t get loaded in the worker R process. For the post, I’ll just phony up a model that happens to not be loaded:\nThis code loads and then unloads the model, and then shows that it is not loaded:\n\nmod <- modlib(\"pk1\")\n\nBuilding pk1 ... done.\n\nmrgsolve:::unloadso.mrgmod(mod)\n\nunloaded pk1-so-59812455e037.so\n\nmrgsolve:::funset(mod)\n\n$symbols\n                 name loaded\n1   _model_pk1_main__  FALSE\n2    _model_pk1_ode__  FALSE\n3  _model_pk1_table__  FALSE\n4 _model_pk1_config__  FALSE\n\n$shlib\n              package    version compiled\n1 pk1-so-59812455e037 1.0.8.9000     TRUE\n\n\nWe can still simulate from this model; mrgsolve will determine that the model isn’t loaded and it will try to load it for you.\n\nmrgsim(mod)\n\nModel:  pk1 \nDim:    25 x 5 \nTime:   0 to 24 \nID:     1 \n    ID time EV CENT CP\n1:   1    0  0    0  0\n2:   1    1  0    0  0\n3:   1    2  0    0  0\n4:   1    3  0    0  0\n5:   1    4  0    0  0\n6:   1    5  0    0  0\n7:   1    6  0    0  0\n8:   1    7  0    0  0\n\n\nIt’s possible that the model can’t be loaded (e.g. due to missing .so file). In that case, mrgsolve will give you the usual error message that the model needs to be compiled.\n\n\n6 Time after dose in specific compartment\nVersion 0.10.7 also adds a new plugin with the ability to calculate time after dose in any compartment.\nWe write a model using the tad plugin to track time after dose in compartments one and two. We create tadose objects to track this and we can call the tad() method on these objects, passing in the self data item.\n\ncode <- '\n\n[plugin] tad\n\n[ global ] \nmrg::tadose tad_cmt_1(1); \nmrg::tadose tad_cmt_2(2);\n\n[ pkmodel ] cmt = \"GUT,CENT\", depot = TRUE\n\n[ param ] CL = 1, V = 20, KA = 1\n\n[ main ] \ncapture tad1 = tad_cmt_1.tad(self); \ncapture tad2 = tad_cmt_2.tad(self);\n\n'\n  \nmod <- mcode(\"tad\", code, soloc = '.')\n\nBuilding tad ... done.\n\ndata <- c(\n  ev(amt = 100, cmt = 1, time = 1), \n  ev(amt = 200, cmt = 2, time = 3)\n)\n\nmrgsim(mod, data)\n\nModel:  tad \nDim:    27 x 6 \nTime:   0 to 24 \nID:     1 \n    ID time     GUT   CENT tad1 tad2\n1:   1    0   0.000   0.00   -1   -1\n2:   1    1   0.000   0.00   -1   -1\n3:   1    1 100.000   0.00    0   -1\n4:   1    2  36.788  61.41    1   -1\n5:   1    3  13.534  81.00    2   -1\n6:   1    3  13.534 281.00    2    0\n7:   1    4   4.979 275.61    3    1\n8:   1    5   1.832 265.22    4    2\n\n\nNote that time after dose is -1 until a dose is administered.\nRecall also that time after dose can be calculated more simply if there is only one dose type by passing the tad argument:\n\ndata1 <- filter(data, cmt ==1) %>% mutate(time = 3)\nmod %>% mrgsim(data1, tad = TRUE)\n\nModel:  tad \nDim:    26 x 7 \nTime:   0 to 24 \nID:     1 \n    ID time tad     GUT  CENT tad1 tad2\n1:   1    0  -3   0.000  0.00   -1   -1\n2:   1    1  -2   0.000  0.00   -1   -1\n3:   1    2  -1   0.000  0.00   -1   -1\n4:   1    3   0   0.000  0.00   -1   -1\n5:   1    3   0 100.000  0.00    0   -1\n6:   1    4   1  36.788 61.41    1   -1\n7:   1    5   2  13.534 81.00    2   -1\n8:   1    6   3   4.979 85.36    3   -1\n\n\nThis is a little nicer because it will fill in negative tad values for you.\n\n\n7 Improved handling of time-varying covariates\nThis one is a little harder to demonstrate. mrgsolve has always been able to simulate time-varying covariates, but it hasn’t always inserted a hard discontinuity when parameter values change in the data set over time. Starting in 0.10.7, when parameters are read from the data-set and they change from record to record, we now re-initialize the ode solver so a hard discontinuity is created in the simulation. This will create more accurate simulations around the time that the covariate value changes. This results in no change when running 1- and 2-compartment models which are handled with the closed form equations."
  },
  {
    "objectID": "posts/rmd_model.html",
    "href": "posts/rmd_model.html",
    "title": "Rmarkdown model specification",
    "section": "",
    "text": "1 Introduction\nI was an Emacs user for a long time and thought I’d never give it up. But like a lot of other people, Rstudio grew on me and I use it for all my R, C++ and Rcpp work. It just works well.\n\n\n2 The problem\nWhen I write mrgsolve models, I typically save the code to a file with .cpp extension (e.g. pkmodel.cpp) so that I get nice syntax highlighting that Rstudio provides. One thing that bugs me about this setup is that Rstudio naturally thinks all the code in pkmodel.cpp is C++ code. But for mrgsolve models, only part of the code is C++. Other parts are R or just other syntax that we made up. This means the auto-formatting that Rstudio does doesn’t always work that great.\n\n\n3 Some solutions\nThere are a couple of ways to make this less-irritating. First, you can use brackets for code blocks like this\n\n[ PARAM] CL = 1, V = 20\n\nrather than this\n\n$PARAM CL = 1, V = 20\n\nI think this helps a bit. You could also save your model to pkmodel.txt rather than pkmodel.cpp. You will lose all of the C++ conveniences but Rstudio won’t try to auto-format your code. This might not be a great solution either.\n\n\n4 Rmarkdown model specification\nAnother way to deal with this is to write your model in Rmarkdown format. This is new in version 0.9.1 and will probably need some tweaking. But I’m generally happy with the way it’s working so far.\nThe models run the same regardless of how you code them. But in the Rmarkdown input format, writing the code might be a little more natural. Also, consistent the the Rmarkdown / literate programming philosophy, you can document your model right as you code the model, but with structured markdown input.\nFor example you can now load this model\n\nlibrary(mrgsolve)\noptions(mrgsolve.soloc = \"build\")\n\nmod <- mread_cache(\"popex.Rmd\", modlib())\n\nThis is just a pop-PK model. You can take a closer look at the code here.\n\nmod %>% ev(amt = 100) %>% mrgsim(nid = 30, end = 72) %>% plot()\n\n\n\n\nBut it’s written in Rmd format\n\ncat(mod@code, sep = \"\\n\")\n\n. ---\n. title: \"Test Rmd model spec\"\n. output: mrgsolve:::document\n. ---\n. \n. ```{R setup, echo=FALSE}\n. knitr::opts_chunk$set(eval=FALSE)\n. ```\n. \n. # Parameters\n. ```{param}\n. TVKA = 0.5, TVCL = 1, TVV = 24, WT=70\n. ```\n. \n. # OMEGA\n. ```{omega}\n. @labels ECL EV EKA\n. 0.3 0.1 0.5\n. ```\n. \n. # SIGMA\n. ```{sigma}\n. 0\n. ```\n. \n. # Main block\n. ```{main}\n. double CL = exp(log(TVCL) + 0.75*log(WT/70) + ECL);\n. double V  = exp(log(TVV)  +      log(WT/70) + EV );\n. double KA = exp(log(TVKA)                   + EKA);\n. ```\n. \n. # Model\n. ```{pkmodel}\n. cmt = \"GUT CENT\", depot = TRUE\n. ```\n. \n. # Table\n. ```{table}\n. capture IPRED = CENT/V;\n. capture DV = IPRED*exp(EPS(1));\n. ```\n. \n. # Outputs\n. ```{capture}\n. CL V ECL\n. ```\n\n\nAt the top of the document, there is regular yaml front matter, with a title (and optionally date, author etc). I have also included output which is set to mrgsolve:::document. The ::: indicates that document is not exported from the mrgsolve namespace. But using this output lets you knit this document in Rstudio (with the knit button) and you will get some html output. This just renders the code into a nice format (with all the comments and section headers you include in regular old Rmarkdown format). The mrgsolve:::document output type defines all sorts of engines like param and cmt and main and ode etc. These are block names like you would write in the original input specification ($PARAM and $CMT etc). So only code in backticks with an engine will be handled as proper model code, the rest is discarded. There are absolutely no differences in how the code itself is handled with either the Rmd input format or the traditional input format. The only difference is the code used to mark the end of one block and the start of another block.\nIf you want to write (and evaluate) some R code, use the R engine.\nThe only way to properly process a file written like this is if it has the extension .Rmd or .rmd. So only use those extensions if you have written your model with the Rmarkdown block delimiters."
  },
  {
    "objectID": "posts/2017-complete-example.html",
    "href": "posts/2017-complete-example.html",
    "title": "A Complete Example",
    "section": "",
    "text": "We had a user who was learning mrgsolve ask for a “complete example”. I wasn’t sure what exactly that meant, but I created this example and I’m sharing it today on the blog.\nThis is an invented example to illustrate features and workflow for mrgsolve. If you attend one of our training workshops, we work examples using published models to answer real questions you’ll encounter in drug development. So compared to the workshop material, this is a bit contrived. But I wanted to show how you might tackle a problem involving a population model from end to end.\n\nlibrary(mrgsolve)\nlibrary(dplyr)\nlibrary(dmutate)\nlibrary(ggplot2)\n\n\n1 Population PK model\n\nOne compartment with first order absorption\n\nThere are no ODEs in this model; the system is advanced for each time step through closed-form equations for the amount in each compartment\n\nCovariates: weight on clearances and volumes, sex on volume\nLog-normally distributed random effects on CL, V, and KA\nReduced bioavailability fraction for oral doses\nLag time for oral doses\nCombined additive and proportional error model\n\nNote: we resimulate residual error variates using simeps until the simulated concentration is positive\n\n\nHere’s the model specification\n\ncode <- '\n$PARAM TVCL = 1.23, TVV = 35.7, TVKA = 1.3\nF1 = 0.82, ALAG = 1.21\nWT = 70, SEX = 0\n\n$MAIN\ndouble CL = TVCL*pow(WT/70,0.75)*exp(ECL);\ndouble V  = TVV*(WT/70)*exp(EV);\ndouble KA = TVKA*exp(EKA);\n\nif(SEX==1) V = V*0.8;\n\nF_GUT = F1;\nALAG_GUT = ALAG;\n\n$PKMODEL cmt=\"GUT CENT\", depot=TRUE\n\n$OMEGA @labels ECL EV EKA\n0.015 0.2 0.5\n\n$SIGMA @labels PROP ADD\n0.03 230\n\n$TABLE\ncapture IPRED = CENT/(V/1000);\ncapture DV = IPRED*(1+PROP)+ADD;\n\nwhile(DV < 0) {\n  simeps();\n  DV = IPRED*(1+PROP)+ADD;\n}\n\n$CAPTURE WT CL \n'\n\nCompile and load the model\nWe use mcode_cache here, which caches the model when you compile. If the cache is not invalidated, mrgsolve loads from the cache next time rather than re-compiling.\n\nmod <- mcode_cache(\"demo\", code)\n\nBuilding demo ... done.\n\n\n\n\n2 Input data set\n\nN=2000 patients are simulated in this example\nWe simulate patient-level weight and sex using the dmutate package\nWe create a flag in the data set for patients with weight greater than 90 kg\nPatients with weight less than 90 kg get a certain dose while patients with weight greater than 90 kg get a higher dose\nDosing proceeds Q24H x 10 doses\n\n\nset.seed(33020)\nidata <- \n  data_frame(ID=1:2000) %>% \n  mutate_random(WT[50,110] ~ rnorm(80,30)) %>% \n  mutate_random(SEX ~ rbinomial(0.7)) %>%\n  mutate(dosegr = as.integer(WT > 90))\n\nWarning: `data_frame()` was deprecated in tibble 1.1.0.\nℹ Please use `tibble()` instead.\n\nidata\n\n# A tibble: 2,000 × 4\n      ID    WT   SEX dosegr\n   <int> <dbl> <dbl>  <int>\n 1     1  52.6     0      0\n 2     2  83.7     1      0\n 3     3  51.9     1      0\n 4     4  94.7     0      1\n 5     5  97.8     1      1\n 6     6  57.1     1      0\n 7     7 101.      0      1\n 8     8  73.0     0      0\n 9     9  56.3     1      0\n10    10  69.7     1      0\n# … with 1,990 more rows\n\n\nThe dosing elements are implemented through event objects.\n\nev1 <- ev(amt=100, ii=24, addl=9)\nev2 <- ev(amt=150, ii=24, addl=9)\n\nThe assign_ev function looks at the dosegr column in idata and assigns a dosing event sequence (e1 or e2) based on the value of dosegr.\n\ndata <- assign_ev(list(ev1,ev2),idata,\"dosegr\")\n\nhead(data)\n\n  time amt ii addl cmt evid ID\n1    0 100 24    9   1    1  1\n2    0 100 24    9   1    1  2\n3    0 100 24    9   1    1  3\n4    0 150 24    9   1    1  4\n5    0 150 24    9   1    1  5\n6    0 100 24    9   1    1  6\n\n\nNOTE: this is just one way to set up a data_set for mrgsolve. It might not be the best approach for your problem: maybe it’s too complicated, maybe not complicated enough. See other examples in the blog about creating input data sets or using event objects in your simulations.\n\n\n3 Simulation\n\nWe “carry” (copy) the dose group indicator into the simulated output (carry_out)\nAlso, we only collect observation records in the output (obsonly)\nmrgsolve respects the seed you set in R using set.seed so that results are reproducible\n\n\nset.seed(11009)\n\nout <- \n  mod %>% \n  data_set(data) %>%\n  idata_set(idata) %>%\n  carry_out(dosegr) %>%\n  mrgsim(delta=1, end=360, obsonly=TRUE)\n\nout\n\nModel:  demo \nDim:    722000 x 9 \nTime:   0 to 360 \nID:     2000 \n    ID time dosegr      GUT  CENT    WT     CL IPRED      DV\n1:   1    0      0  0.00000  0.00 52.56 0.9589     0   19.92\n2:   1    1      0  0.00000  0.00 52.56 0.9589     0   12.37\n3:   1    2      0 29.31933 51.23 52.56 0.9589  3236 1954.41\n4:   1    3      0  7.97557 68.80 52.56 0.9589  4345 5355.78\n5:   1    4      0  2.16955 70.36 52.56 0.9589  4443 3438.75\n6:   1    5      0  0.59017 67.74 52.56 0.9589  4278 3689.13\n7:   1    6      0  0.16054 64.18 52.56 0.9589  4053 4843.27\n8:   1    7      0  0.04367 60.52 52.56 0.9589  3822 5287.74\n\n\n\n\n4 Output presentation\n\nFor some plots, we use a plot method for mrgsims objects (the object that is returned from the mrgsim function\nFor the other plots, it’s really just turning the mrgsims object into a data.frame and have at it with ggplot2\nOther than the quickie lattice-based plot method that I only use for quick looks at the output, mrgsolve (by design) lets you use packages like dplyr or data.table or ggplot or other great R packages that are already out there for summarizing and plotting data\nBut notice that mrgsolve provides methods for sending the mrgsims object directly into a dplyr data summary pipeline\n\nThis shows the plot method for mrgsims objects\n\nplot(out, IPRED+DV~., subset=ID==10)\n\n\n\n\nThe mrgsims object can be passed right into dplyr::filter\n\ntr <- filter(out, time==240)\n\nSimulated day 10 concentration versus patient weight by dose/weight group\n\nggplot(tr, aes(x=WT,y=DV)) + \n  geom_point() +  facet_wrap(~dosegr) +\n  geom_smooth(method=\"loess\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nDensity plots of day 10 concentrations in the two dose/weight groups\n\nggplot(tr,aes(x=DV,fill=factor(dosegr))) + \n  geom_density(alpha=0.5) +\n  scale_fill_brewer(palette=\"Set1\")\n\n\n\n\n\n\n5 Summary\nThis example illustrated how to code a population PK model in mrgsolve format, create input data sets with varied dosing and covariate values, simulate, and plot some results. I also hope this example illustrates the design priorities for the mrgsolve workflow: we always try to leverage existing functionality available in R (such as dmutate, dplyr and ggplot) rather than re-creating our own inside the mrgsolve package. This might require you to write some more code, but ultimately it gives greater flexibility to get the simulation that you need for your project.\nWe regularly do work with models that are more complicated and design simulations that have bigger demands than this example here. We’d be happy to discuss more-complicated applications that you might be needing for your project work. For now we hope this example will give you some ideas how you can add complexity to your simulation project today."
  },
  {
    "objectID": "posts/2017-reproducible.html",
    "href": "posts/2017-reproducible.html",
    "title": "Reproducible results with set.seed",
    "section": "",
    "text": "library(mrgsolve)\nlibrary(dplyr)"
  },
  {
    "objectID": "posts/2017-reproducible.html#identical-in-the-first-day",
    "href": "posts/2017-reproducible.html#identical-in-the-first-day",
    "title": "Reproducible results with set.seed",
    "section": "4.1 Identical in the first day …",
    "text": "4.1 Identical in the first day …\n\nidentical(filter(single, time < 24),filter(multi,time < 24))\n\n. [1] TRUE"
  },
  {
    "objectID": "posts/2017-reproducible.html#but-not-after-that",
    "href": "posts/2017-reproducible.html#but-not-after-that",
    "title": "Reproducible results with set.seed",
    "section": "4.2 … but not after that",
    "text": "4.2 … but not after that\n\nfilter(single, time > 24)\n\n. # A tibble: 0 × 5\n. # … with 5 variables: ID <dbl>, time <dbl>, CENT <dbl>, ETA1 <dbl>, ETA2 <dbl>\n\nfilter(multi, time > 24)\n\n. # A tibble: 21,600 × 5\n.       ID  time  CENT  ETA1  ETA2\n.    <dbl> <dbl> <dbl> <dbl> <dbl>\n.  1     1    25 124.   1.75 -1.40\n.  2     1    26 118.   1.75 -1.40\n.  3     1    27 112.   1.75 -1.40\n.  4     1    28 107.   1.75 -1.40\n.  5     1    29 101.   1.75 -1.40\n.  6     1    30  96.4  1.75 -1.40\n.  7     1    31  91.7  1.75 -1.40\n.  8     1    32  87.2  1.75 -1.40\n.  9     1    33  83.0  1.75 -1.40\n. 10     1    34  78.9  1.75 -1.40\n. # … with 21,590 more rows"
  },
  {
    "objectID": "posts/mtime.html",
    "href": "posts/mtime.html",
    "title": "mtime",
    "section": "",
    "text": "This is just a short post on a simplified implementation of modeled events in mrgsolve.\nI previously posted here about modeling interventions in mrgsolve. All that still works fine. But I found myself wanting a more straightforward implementation of the mtime functionality you get in NONMEM.\n\n1 Example with single mtime\nFor example, we might wish a rate constant to change at some time that is not found in a record in the input data set. We can make this happen from the model code itself. In addition to using mevent you can now use mtime to make this happen. mtime is just a simpler subset of the mevent functionality.\nLet’s make KA change at 2.1 hours (change_t parameter in the example below).\n\n[ param ]\nCL = 1, V = 20, KA1 = 0.1, KA2 = 2.5, change_t = 2.1\n\n[ pkmodel ] \ncmt = \"GUT,CENT\", depot = TRUE\n\n[ main ] \ndouble mt = self.mtime(change_t);\n\ncapture KA = KA1;\n\nif(TIME > mt) KA = KA2;\n\nif(TIME == change_t) {\n  mrg::report(\"wait a minute ... time is 2.1?\");  \n}\n\nAgain, the main motivation for this is just convenience and economy of code: we register the event time and get that time returned into a variable that we can reference later on, checking if we are past that time or not.\n\nlibrary(mrgsolve)\n\noptions(mrgsolve.soloc = \"build\")\n\nmod <- mread_cache(\"mtime_model.txt\")\n\nmod %>% ev(amt=100) %>% mrgsim(delta = 0.222) %>% plot(CENT+KA~time)\n\n\n\n\nYou won’t see the message that we actually stumbled on 2.1 hours in the simulation even though it was not in the lineup when the simulation started.\n\n\n2 Example with several mtimes\nWe could keep track of several mtimes like this\n\n[ set ] end=8, delta=0.1\n\n[ param ]\nCL = 1, V = 20, KA1 = 0.1, KA2 = 0.5, KA3 = 5, change_t = 1\n\n[ pkmodel ] \ncmt = \"GUT,CENT\", depot = TRUE\n\n[ main ] \ndouble mt = self.mtime(change_t);\n\ndouble mt2 = self.mtime(change_t + 1);\n\ncapture KA = KA1;\n\nif(TIME > mt) KA = KA2;\n\nif(TIME > mt2) KA = KA3;\n\n\nmod <- mread_cache(\"mtime_model_2.txt\")\n\nmod %>% ev(amt=100) %>% mrgsim() %>% plot(CENT + KA ~ time)"
  },
  {
    "objectID": "posts/new-0-10-1.html",
    "href": "posts/new-0-10-1.html",
    "title": "New in 0.10.0 and 0.10.1",
    "section": "",
    "text": "library(dplyr)\nlibrary(mrgsolve)\n\n\n1 Introduction\nThis blog post shows some of the new features that came into mrgsolve starting with version 0.10.0 (October 2019) and 0.10.1 (February 2020). The purpose is to illustrate what is possible rather than detailed documentation.\n\n\n2 Steady-state\nThis is a big topic, so I put together a separate blog entry to look at new features around steady state.\n\n\n3 house is now exported\nSince the beginning, we have maintained a model inside mrgsolve itself that we call house. It’s a basic PKPD model that we use to test and demo. The interesting thing about this model is that it is compiled when mrgsolve is installed. So the model is always ready to go.\nIt use to be unexported so you would have to access the model like this:\n\nmod <- mrgsolve:::house()\n\nThe ::: means that we go into the mrgsolve namespace to call the function that returns the model object.\nNow, house is exported\n\nmod <- house()\n\n\n\n4 select_sims\nThere is a series of dplyr-like functions that allow you to work on the simulation output object (mrgsims) while keeping it a simulation output object. Starting in version 0.10.1, we have a select_sims function which allows you to select certain columns in the simulation object\n\nout <- mrgsim(house(), ev(amt = 100))\n\nout \n\nModel:  housemodel \nDim:    482 x 7 \nTime:   0 to 120 \nID:     1 \n    ID time    GUT  CENT  RESP    DV    CP\n1:   1 0.00   0.00  0.00 50.00 0.000 0.000\n2:   1 0.00 100.00  0.00 50.00 0.000 0.000\n3:   1 0.25  74.08 25.75 48.68 1.287 1.287\n4:   1 0.50  54.88 44.50 46.18 2.225 2.225\n5:   1 0.75  40.66 58.08 43.61 2.904 2.904\n6:   1 1.00  30.12 67.83 41.38 3.391 3.391\n7:   1 1.25  22.31 74.74 39.58 3.737 3.737\n8:   1 1.50  16.53 79.56 38.18 3.978 3.978\n\nout <- select_sims(out, RESP, CP)\n\nout\n\nModel:  housemodel \nDim:    482 x 4 \nTime:   0 to 120 \nID:     1 \n    ID time  RESP    CP\n1:   1 0.00 50.00 0.000\n2:   1 0.00 50.00 0.000\n3:   1 0.25 48.68 1.287\n4:   1 0.50 46.18 2.225\n5:   1 0.75 43.61 2.904\n6:   1 1.00 41.38 3.391\n7:   1 1.25 39.58 3.737\n8:   1 1.50 38.18 3.978\n\n\nNotice that ID and time are retained. The motivation here is to allow you to request many columns and then pare back so that, for example, plotting is more convenient\n\nplot(out)\n\n\n\n\nOther functions include\n\nmutate_sims(out, name = \"kyle\")\n\nModel:  housemodel \nDim:    482 x 5 \nTime:   0 to 120 \nID:     1 \n    ID time  RESP    CP name\n1:   1 0.00 50.00 0.000 kyle\n2:   1 0.00 50.00 0.000 kyle\n3:   1 0.25 48.68 1.287 kyle\n4:   1 0.50 46.18 2.225 kyle\n5:   1 0.75 43.61 2.904 kyle\n6:   1 1.00 41.38 3.391 kyle\n7:   1 1.25 39.58 3.737 kyle\n8:   1 1.50 38.18 3.978 kyle\n\n\n\nfilter_sims(out, time > 2)\n\nModel:  housemodel \nDim:    472 x 4 \nTime:   2.25 to 120 \nID:     1 \n    ID time  RESP    CP\n1:   1 2.25 35.84 4.312\n2:   1 2.50 35.46 4.345\n3:   1 2.75 35.22 4.355\n4:   1 3.00 35.07 4.348\n5:   1 3.25 34.99 4.329\n6:   1 3.50 34.97 4.302\n7:   1 3.75 34.98 4.267\n8:   1 4.00 35.03 4.229\n\n\nNotice in all of these operations, the mrgsims object is returned. If you want to mutate or select and get a tibble back, then just call\n\nmutate(out, name = \"Kyle\")\n\n# A tibble: 482 × 5\n      ID  time  RESP    CP name \n   <dbl> <dbl> <dbl> <dbl> <chr>\n 1     1  0     50    0    Kyle \n 2     1  0     50    0    Kyle \n 3     1  0.25  48.7  1.29 Kyle \n 4     1  0.5   46.2  2.23 Kyle \n 5     1  0.75  43.6  2.90 Kyle \n 6     1  1     41.4  3.39 Kyle \n 7     1  1.25  39.6  3.74 Kyle \n 8     1  1.5   38.2  3.98 Kyle \n 9     1  1.75  37.1  4.14 Kyle \n10     1  2     36.4  4.25 Kyle \n# … with 472 more rows\n\n\n\n\n5 Plot from character vector of column names\nThe plot method has so far required you to enter a formula to select columns to plot\n\nout <- mrgsim(house(), ev(amt = 100))\n\nplot(out, CP~time)\n\n\n\n\nThis works well is many circumstances. The new feature here is that you can list the columns to plot as a character vector. Let’s mrgsolve determine what column to put on the x-axis\n\nplot(out, \"CP RESP GUT\")\n\n\n\n\nThe motivation came from simulations that I was doing where there were a lot of columns in the output and I had many different panel plots I wanted to make. It was helpful to select the columns in a character vector rather than typing out the formula\n\nmod <- modlib(\"pbpk\")\n\nBuilding pbpk ... done.\n\nout <- mrgsim(mod, ev(amt = 100))\n\n\nset1 <- \"Aad Abo Abr Ahe\"\nset2 <- \"Ave Are Ask Asp Ali Aki\"\n\nplot(out, set1)\n\n\n\nplot(out, set2)\n\n\n\n\nAs you expect with mrgsolve, there is no need to specify a real R vector for listing the column names. We’ll split a string on space or comma. For this feature, we’ll also split on newline (helpful when the names are very long or you just want some structure to the layout\n\nset3 <- '\n  Aad Abo Abr Ahe\n  Ave Are Ask Asp Ali Aki\n'\n\nplot(out, set3)\n\n\n\n\n\n\n6 outvars\nQuery the model object for the names of variables that you could ask for in a simulation\n\noutvars(house())\n\n$cmt\n[1] \"GUT\"  \"CENT\" \"RESP\"\n\n$capture\n[1] \"DV\" \"CP\"\n\n\nSome names are compartments, some are captured.\n\n\n7 Improvements to event objects\nTo make an event object\n\nev(amt = 100)\n\nEvents:\n  time amt cmt evid\n1    0 100   1    1\n\n\nWe can reference names in the object during construction\n\nev(amt = 100, rate = amt/2)\n\nEvents:\n  time amt rate cmt evid\n1    0 100   50   1    1\n\n\nI can also access columns in the event object\n\nx <- ev(amt = 100, rate = amt/3)\nx$rate\n\n[1] 33.33333\n\n\nAnd we have been able to mutate these objects for a while now\n\nx <- ev(amt = 100) \n\nmutate(x, rate = amt / 5)\n\nEvents:\n  time amt rate cmt evid\n1    0 100   20   1    1\n\n\nCheck out the tinf argument to say how long you want an infusion to last\n\nev(amt = 100, tinf = 3)\n\nEvents:\n  time amt     rate cmt evid tinf\n1    0 100 33.33333   1    1    3\n\n\n\n\n8 New error message\nYou might see this\n\ndose <- ev(amt = 100)\n\ntry(mrgsim(dose, mod))\n\nError : the first argument to mrgsim must be a model object\n\n\nWhich just means you passed things in in the wrong order.\n\n\n9 Steady state infusion\nmrgsolve can now run a zero-order infusion to steady state. Set amt to 0, rate to something positive and ss to 1. We change recsort just to show that things start at steady state.\n\nssinf <- ev(amt = 0, rate = 5, ss = 1)\n\nmrgsim(house(), event = ssinf, recsort=3) %>% plot\n\n\n\n\nYou can also set rate to -1 if you are modeling the rate. But it can’t be set to -2.\n\n\n10 Access model information\nFor a while, you could access model parameters with $ operator\n\nmod <- house()\n\nmod$CL\n\n[1] 1\n\n\nNow you can access initial compartment values\n\nmod$RESP\n\n[1] 50\n\n\nAnd other goodies\n\nmod$end\n\n[1] 120\n\n\n\n\n11 Access compartment numbers\nSometimes when writing a model, we would like to know the number of a compartment when we only know the name. There is a plugin to make that doable now\n\n$CMT CENTRAL\n\n$PLUGIN N_CMT\n\n$MAIN\n\nif(CMT==N_CENTRAL) {\n  // ......\n}"
  },
  {
    "objectID": "posts/2018-pred.html",
    "href": "posts/2018-pred.html",
    "title": "Models without compartments",
    "section": "",
    "text": "1 Introduction\nThis post introduces a new formal code block for writing models where there are no compartments. The block is named after the analogous NONMEM block called $PRED. This functionality has always been possible with mrgsolve, but only now is there a code block dedicated to these models. Also, a relaxed set of data set constraints have been put in place when these types of models are invoked.\n\n\n2 Example model\nAs a most-basic model, we look at the pred1 model in modlib()\n\nlibrary(mrgsolve)\noptions(mrgsolve.soloc=\"build\")\nmod <- mread_cache(\"pred1\", modlib())\n\nThe model code is\n\n$PROB\nAn example model expressed in closed form\n$PARAM B = -1, beta0 = 100, beta1 = 0.1\n$OMEGA 2 0.3\n$PRED\ndouble beta0i = beta0 + ETA(1);\ndouble beta1i = beta1*exp(ETA(2));\ncapture Y = beta0i + beta1i*B;\n\nThis is a random-intercept, random slope linear model. Like other models in mrgsolve, you can write parameters ($PARAM), and random effects ($OMEGA). But the model is actually written in $PRED.\nWhen mrgsolve finds $PRED, it will generate an error if it also finds $MAIN, $TABLE, or $ODE. However, the code that gets entered into $PRED would function exactly as if you put it in $TABLE.\nIn the example model, the response is a function of the parameter B, so we’ll generate an input data set with some values of B\n\nlibrary(dplyr)\ndata <- tibble(ID = 1, B = exp(rnorm(100, 0,2)))\n\nhead(data)\n\n# A tibble: 6 × 2\n     ID       B\n  <dbl>   <dbl>\n1     1   3.76 \n2     1 196.   \n3     1   2.90 \n4     1   0.168\n5     1   0.278\n6     1   0.773\n\n\n\nout <- mrgsim_d(mod,data,carry.out=\"B\")\n\nplot(out, Y~B)\n\n\n\n\nLike other models, we can simulate from a population\n\nlibrary(purrr)\nset.seed(223)\ndf <- map_df(1:30, function(i) tibble(ID = i, B = seq(0,30,1)))\n\nhead(df)\n\n# A tibble: 6 × 2\n     ID     B\n  <int> <dbl>\n1     1     0\n2     1     1\n3     1     2\n4     1     3\n5     1     4\n6     1     5\n\nmod %>% \n  data_set(df) %>% \n  mrgsim(carry.out=\"B\") %>%\n  plot(Y ~ B)\n\n\n\n\n\n\n3 PK/PD Model\nHere is an implementation of a PK/PD model using $PRED\nIn this model\n\nCalculate CL as a function of WT and a random effect\nDerive AUC from CL and DOSE\nThe response (Y) is a calculated from AUC and the Emax model parameters\n\n\ncode <- '\n$PARAM TVCL = 1, WT = 70, AUC50 = 20, DOSE = 100, E0 = 35, EMAX = 2.4\n\n$OMEGA 1\n\n$SIGMA 100\n\n$PRED\ndouble CL = TVCL*pow(WT/70,0.75)*exp(ETA(1));\ncapture AUC = DOSE/CL;\ncapture Y = E0*(1+EMAX*AUC/(AUC50+AUC))+EPS(1);\n'\n\n\nmod <- mcode_cache(\"pkpd\", code)\n\nLoading model from cache.\n\n\nTo simulate, look at 50 subjects at each of 5 doses\n\ndata <- \n  expand.idata(DOSE = c(30,50,80,110,200),ID = 1:50) %>% \n  mutate(WT = exp(rnorm(n(),log(80),1)))\n\nhead(data)\n\n  ID DOSE        WT\n1  1   30  59.13254\n2  2   50 317.32739\n3  3   80 242.15746\n4  4  110 170.78136\n5  5  200 248.18054\n6  6   30  51.22012\n\n\n\nout <- mrgsim_d(mod,data,carry.out=\"WT,DOSE\") %>% as.data.frame\n\nhead(out)\n\n  ID time        WT DOSE       AUC         Y\n1  1    0  59.13254   30 231.90852 110.61330\n2  2    0 317.32739   50  36.76051  85.27834\n3  3    0 242.15746   80  36.54808  98.90407\n4  4    0 170.78136  110  23.68354  80.29131\n5  5    0 248.18054  200 331.10229 108.81926\n6  6    0  51.22012   30 251.58373 116.09649\n\n\nPlot the response (Y) versus AUC, colored by dose\n\nlibrary(ggplot2)\n\nggplot(out, aes(AUC,Y,col =factor(DOSE))) + \n  geom_point() + \n  scale_x_continuous(trans = \"log\", breaks = 10^seq(-4,4)) + \n  geom_smooth(aes(AUC,Y),se = FALSE,col=\"darkgrey\") + theme_bw() + \n  scale_color_brewer(palette = \"Set2\", name = \"\") + \n  theme(legend.position = \"top\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'"
  },
  {
    "objectID": "posts/2023-new-1.0.8.html",
    "href": "posts/2023-new-1.0.8.html",
    "title": "New in 1.0.8",
    "section": "",
    "text": "1 Introduction\nmrgsolve version 1.0.8 was released to CRAN on March 4th, 2023. This blog post introduces some of the new features in 1.0.8 as well as 1.0.7, which was not released to CRAN.\n\nlibrary(mrgsolve)\nlibrary(readr)\nlibrary(dplyr)\n\n\n\n2 Missing values and input data sets\nMissing values (NA) are now allowed in the following columns of input data sets:\n\nCMT\nAMT\nRATE\nEVID\nII\nADDL\nSS\n\nThe lower case versions of these names may also include NA.\n\ncmt\namt\nrate\nevid\nii\naddl\nss\n\nIn previous versions of mrgsolve, it was an error to include NA in these data set columns. Starting with version 1.0.7, mrgsolve will convert NA to 0 for these columns only. mrgsolve will continue to warn the user when missing values are in parameter columns.\n\n\n3 Convenient ETA capture\nThe $CAPTURE block gains a new option for capturing any or all ETAs into the simulated output. The user writes an expression which evaluates to the integer numbers of ETAs to capture into the @etas option. For example\n\n$OMEGA 0.1 0.2 0.3\n\n$CAPTURE @etas 1:LAST\nCL Y\n\nwill capture ETAs 1, 2, and 3 into ETA1, ETA2, and ETA3 in the simulated output.\nNote that the syntax resembles what you might write in NONMEM where last is the total number of ETAs in the problem.\nNote also that ETA naming resembles what you would get from NONMEM. This is contrasted with the naming that you continue to get when you simply capture ETA(1)\n\n$CAPTURE \nCL Y ETA(1)\n\nIn this case, the name would be ETA_1, with () getting removed and replaced with _. This sanitization of names happens any time a captured item has parens or brackets in the name.\n\n\n4 New model macro: SIGMA()\nThe user can now access on-diagonal elements of $SIGMA through the SIGMA() macro. For example\n\n$SIGMA 0.1 12\n\n$TABLE\ndouble STD=sqrt(SIGMA(1)+pow(F,2)*SIGMA(2));\n\nThis macro provides read-only access to the $SIGMA elements.\n\n\n5 Matching mrgsolve and NONMEM run numbers\nWhen a mrgsolve model is translated from a NONMEM run, it is common to give them matching file names. For example, if 101.ctl is the NONMEM control stream name, we might create an mrgsolve version of that run as 101.cpp or 101.mod.\nIn this case, we will likely use $NMEXT or $NMXML blocks to import the estimates from the completed NONMEM run with code like this\n\n$NMEXT\nrun = 101\nproject = \"model/nonmem\"\n\nif the run completed in the model/nonmem directory.\nStarting with mrgsolve version 1.0.7, users can assume this connection in run numbers by setting the run to @cppstem\n\n$NMEXT\nrun = \"@cppstem\"\nproject = \"model/nonmem\"\n\nThis tells $NMEXT (and $NMXML) to look for 101.ext (or 101.xml) in the model/nonmem/101 directory. Using this syntax will relieve the user from having to update the run number in these blocks when forking one model file to match a new NONMEM run.\n\n\n6 Scrape ETAs from the input data set\nmrgsim() gains a new argument called etasrc which allows you to look to the data set for ETAs rather than simulating them from $OMEGA. This feature has several applications, including validation of your model translation from NONMEM and simulating from empirical Bayes estimates. These topics will be covered more in depth in separate blog posts.\nFor now, let’s look at an example. This model has three ETAs\n\nmod <- mcode(\"etas\", \n  '\n  $OMEGA 1 2 3\n  $CAPTURE @etas 1:last\n  ', \n  end = 3\n)\n\nBy default, the ETAs are random draws from $OMEGA\n\nmrgsim(mod, end = -1, nid = 4) \n\nModel:  etas \nDim:    4 x 5 \nTime:   0 to 0 \nID:     4 \n    ID time    ETA1    ETA2    ETA3\n1:   1    0  0.6358  2.0476  2.5184\n2:   2    0 -1.0663 -0.9353  1.3713\n3:   3    0 -0.9820 -1.6954 -0.9905\n4:   4    0 -0.5072  0.6018 -2.0783\n\n\nWhen you have ETAs coded into your data set\n\ndata <- expand.ev(cmt = 0, ETA1 = 0.1, ETA2 = 0.2, ETA3 = 0.3)\ndata\n\n  ID time amt cmt evid ETA1 ETA2 ETA3\n1  1    0   0   0    1  0.1  0.2  0.3\n\n\nyou can ask mrgsolve to use the data set ETAs rather than simulating new ones\n\nmrgsim(mod, data, etasrc = \"data\")\n\nModel:  etas \nDim:    5 x 5 \nTime:   0 to 3 \nID:     1 \n    ID time ETA1 ETA2 ETA3\n1:   1    0  0.1  0.2  0.3\n2:   1    0  0.1  0.2  0.3\n3:   1    1  0.1  0.2  0.3\n4:   1    2  0.1  0.2  0.3\n5:   1    3  0.1  0.2  0.3\n\n\nIf the data set is missing one of the ETAs, it will be filled with 0\n\nmiss2 <- select(data, -ETA2)\n\nmrgsim(mod, miss2, etasrc = \"data\")\n\nModel:  etas \nDim:    5 x 5 \nTime:   0 to 3 \nID:     1 \n    ID time ETA1 ETA2 ETA3\n1:   1    0  0.1    0  0.3\n2:   1    0  0.1    0  0.3\n3:   1    1  0.1    0  0.3\n4:   1    2  0.1    0  0.3\n5:   1    3  0.1    0  0.3\n\n\nYou can ask for an error to be generated if not all ETAs are found on the data set by using etasrc = \"data.all\"\n\ntry(mrgsim(mod, miss2, etasrc = \"data.all\"))\n\nError : all 3 ETAs must be provided when `etasrc` is \"data.all\".\n\n\nAlso, an error will be generated if you ask for ETAs from the data set, but there are none\n\nmissall <- select(data, -contains(\"ETA\"))\n\ntry(mrgsim(mod, missall, etasrc = \"data\"))\n\nError : at least one ETA must be provided when `etasrc` is \"data\".\n\n\nYou can get more information about the etasrc argument in the ‘Details’ section of the mrgsim() help page.\n\n?mrgsim"
  },
  {
    "objectID": "posts/zero-ss.html",
    "href": "posts/zero-ss.html",
    "title": "Zero-order steady state infusion",
    "section": "",
    "text": "1 Introduction\nStarting with version 0.10.0 (released October, 2019), mrgsolve can implement dosing records calling for a zero-order infusion at steady state. To do this, set rate to a non-zero value, amt to zero, and ss to 1.\n\n\n2 Example\nFor a 10 mg/hr infusion at steady state\n\nlibrary(mrgsolve)\nlibrary(dplyr)\n\nmod <- house(end = 72, delta = 0.1) %>% update(outvars = \"CP\")\n\nmod <- param(mod, CL = 2)\n\ndose <- ev(amt = 0, rate = 100, ss = 1, cmt = 2)\n\nThe dosing event looks like\n\ndose\n\nEvents:\n  time amt rate cmt evid ss\n1    0   0  100   2    1  1\n\n\nWith CL set to 2, we expect the system to start out at 50\n\nmrgsim(mod,dose,recsort = 3) %>% plot()\n\n\n\n\n\n\n3 Notes\n\nIt is an error to include addl\nYou can model the rate\n\nSet rate to -1 in the input data\nSet R_CMT in [main]\n\nIt is an error to try to model the duration\n\nSet rate to -2 in the input data\nSet D_CMT in [main]"
  },
  {
    "objectID": "posts/new-1-0-0.html",
    "href": "posts/new-1-0-0.html",
    "title": "New in 1.0.0",
    "section": "",
    "text": "There are a bunch of new features out now in the mrgsolve 1.0.0 release. Most of these are related to model syntax (what / how you write your model in the .mod or .cpp file) rather than model functionality.\n\nlibrary(mrgsolve)\nlibrary(tidyverse)\n\n\n1 Use THETA(n) to refer to THETAn\nAll models will be able to use THETA(n) to refer to THETAn. For example:\n\n[ nmxml ] \nrun = 100\nroot = \"cppfile\"\n\n[ main ] \ndouble CL = THETA(1) * pow(WT/70, 0.75);\n\nYou’ll notice that we referred to a nonmem run with [ nmxml ] so this syntax is meant be one small step toward making it easier to translate your model from the nonmem control stream to mrgsolve format. This is pretty simple, but will mean less time removing parentheses when copying over model code.\n\n\n2 New plugin called autodec\nPlugins are extra functionality that you can invoke when coding your model. For example, plugins exist for calculating time after dose, adding Rcpp functionality to your model etc and more.\nOne new plugin is called autodec. This plugin will automatically declare C++ variables for you. For example, I can code the snipped from the previous block using autodec plugin and mrgsolve will discover that CL needs to be declared:\n\n[ plugin ] autodec\n\n[ nmxml ] \nrun = 100\nroot = \"cppfile\"\n\n[ main ] \nCL = THETA(1) * pow(WT/70, 0.75);\n\nThe motivation behind this feature is to make it easier to code models with lots of variables when all your variables are simple double precision floating point numbers.\n\n\n3 New plugin called nm-vars\nThis plugin provided a nonmem-like syntax for certain model elements, including\n\nFn, Dn, Rn, and ALAGn\nA(n), A_0(n) and DADT(n)\nT (used for SOLVERTIME in $ODE)\n\nSo your mrgsolve model translated from nonmem might look like this\n\nsee(modlib(\"nm-like\"))\n\nBuilding nm-like ... done.\n\n\n\n$PROB Model written with some nonmem-like syntax features\n\n$PLUGIN nm-vars autodec\n\n$PARAM\nTHETA1 = 1, THETA2 = 21, THETA3 = 1.3, WT = 70, F1I = 0.5, D2I = 2\nKIN = 100, KOUT = 0.1, IC50 = 10, IMAX = 0.9\n\n$CMT @number 3\n\n$PK\nCL = THETA(1) * pow(WT/70, 0.75); \nV  = THETA(2); \nKA = THETA(3);\n\nF1 = F1I;\nD2 = D2I;\nA_0(3) = KIN / KOUT;\n\n$DES \nCP = A(2)/V;\nINH = IMAX*CP/(IC50 + CP);\n  \nDADT(1) = -KA*A(1);\nDADT(2) =  KA*A(1) - (CL/V)*A(2);\nDADT(3) =  KIN * (1-INH) - KOUT * A(3);\n\n$ERROR\nCP = A(2)/V;\n\nNotice that not all nonmem syntax is supported; just select data structures that use A and DADT to refer to compartments and differential equations. Also notice that we still require ; at the end of each line and we still need to use pow(base, exponent) to calculate exponent of some number.\n\n\n4 Compartment\nThe $CMT block has two new options: @number and @prefix that let you quickly specify a numbered series of compartments in the model similar to nonmem. The default @prefix is A so that this code\n\n$CMT @number 3\n\nwill put compartments A1, A2, A3 into your model.\n\n\n5 New model in modlib: nm-like\nYou can see a model coded with these new syntax features in the internal model library; the model is called nm-like\n\nmod <- modlib(\"nm-like\")\nsee(mod)\n\n\nModel file:  nm-like.cpp \n$PROB Model written with some nonmem-like syntax features\n\n$PLUGIN nm-vars autodec\n\n$PARAM\nTHETA1 = 1, THETA2 = 21, THETA3 = 1.3, WT = 70, F1I = 0.5, D2I = 2\nKIN = 100, KOUT = 0.1, IC50 = 10, IMAX = 0.9\n\n$CMT @number 3\n\n$PK\nCL = THETA(1) * pow(WT/70, 0.75); \nV  = THETA(2); \nKA = THETA(3);\n\nF1 = F1I;\nD2 = D2I;\nA_0(3) = KIN / KOUT;\n\n$DES \nCP = A(2)/V;\nINH = IMAX*CP/(IC50 + CP);\n  \nDADT(1) = -KA*A(1);\nDADT(2) =  KA*A(1) - (CL/V)*A(2);\nDADT(3) =  KIN * (1-INH) - KOUT * A(3);\n\n$ERROR\nCP = A(2)/V;\n\n\nHere, I’ve coded the THETAs in a parameter block; these would ordinarily come into the model via $NMXML or $NMEXT, which automatically import these parameters and estimates. But note that we can still refer to THETA(1) and others … this resolves to THETA1 regardless.\n\n\n6 Audit\nWhen mrgsolve loads your model, it checks the $ODE block to make sure you have differential equations for every compartment in your model. A long time ago, I started calling this check audit and it was something that was on by default but could be turned off via the call to mread().\nStarting with version 1.0.0, audit can be controlled at the $ODE block level like this\n\n[ ode ] @audit\n\ndxdt_A1 = ...\ndxdt_A2 = ...\n\nto explicitly tell mrgsolve to audit the equations or\n\n[ ode ] @!audit\n\ndxdt_A1 = ...\ndxdt_A2 = ...\n\nto disable the audit. The audit is on by default and should only be turned off when you have written some special construct in [ ode ] to code the differential equations (e.g. odes are written programmatically).\n\n\n7 New time spacer for event sequences\nThe new feature is an ii spacer for sequences of event objects.\nUsing event objects, we can create complicated dosing regimens from simpler ones. For example, we might have a week of 50 mg dosing followed by a week of 100 mg dosing and then up to 200 mg dosing. We can accomplish that with an event sequence\nFirst create the individual pieces\n\na <- ev(amt = 50,  ii = 24, addl = 6)\nb <- ev(amt = 100, ii = 24, addl = 6)\nc <- ev(amt = 200, ii = 24, addl = 6)\n\nThen put them in a sequence\n\ndata <- ev_seq(a, b, c)\ndata\n\nEvents:\n  time amt ii addl cmt evid\n1    0  50 24    6   1    1\n2  168 100 24    6   1    1\n3  336 200 24    6   1    1\n\n\nWhen they are sequenced, you’ll see that the second piece (b) starts one dosing interval after the last dose in the first piece (a).\nWe can put a 24 hour spacer between a and b\n\nseq(a, wait = 24, b)\n\nEvents:\n  time amt ii addl cmt evid\n1    0  50 24    6   1    1\n2  192 100 24    6   1    1\n\n\nHere, the last dose in a is given, we wait one dosing interval (24 hours) then wait another 24 hours (via wait) and then start b.\nRather than using wait, we can use ii to specify the amount of time from the last dose in a to the first dose in b. So if we want to wait 3 days between the last dose in a and the first dose in b\n\nev_seq(a, ii = 3*24, b)\n\nEvents:\n  time amt ii addl cmt evid\n1    0  50 24    6   1    1\n2  216 100 24    6   1    1\n\n\nNotice that this same behavior can be achieved with wait but using ii might be easier to interpret in some cases.\n\n\n8 Collapse matrices\nSometimes in your model, you have multiple OMEGA or SIGMA blocks like this\n\ncode <- '\n$OMEGA  @name first\n1 2 3\n\n$OMEGA @name second\n4\n'\nmod <- mcode(\"collapse\", code, compile = FALSE)\n\nomat(mod)\n\n$first\n    [,1] [,2] [,3]\n1:     1    0    0\n2:     0    2    0\n3:     0    0    3\n\n$second\n    [,1]\n4:     4\n\n\nIf I want to update these values but I only have a 4x4 matrix\n\nmat\n\n     [,1] [,2] [,3] [,4]\n[1,]  0.1  0.0  0.0  0.0\n[2,]  0.0  0.2  0.0  0.0\n[3,]  0.0  0.0  0.3  0.0\n[4,]  0.0  0.0  0.0  0.4\n\n\nI can’t do it; mrgsolve wants a 3x3 matrix for the first slot and 1x1 matrix for the second.\nA new function will collapse the model matrix into larger matrices\n\nmod <- collapse_omega(mod)\nomat(mod)\n\n$...\n    [,1] [,2] [,3] [,4]\n1:     1    0    0    0\n2:     0    2    0    0\n3:     0    0    3    0\n4:     0    0    0    4\n\n\n\nmod <- update(mod, omat = mat)\nomat(mod)\n\n$...\n    [,1] [,2] [,3] [,4]\n1:     1    0    0    0\n2:     0    2    0    0\n3:     0    0    3    0\n4:     0    0    0    4\n\n\nYou can’t split matrices up into smaller chunks, but if there are more than two blocks, you can select which blocks to join\n\ncode <- '\n$OMEGA  @name first\n1 2 3\n\n$OMEGA @name second\n4\n\n$OMEGA @name third\n5 6 7 8\n'\nmod <- mcode(\"collapse2\", code, compile = FALSE)\n\nomat(mod)\n\n$first\n    [,1] [,2] [,3]\n1:     1    0    0\n2:     0    2    0\n3:     0    0    3\n\n$second\n    [,1]\n4:     4\n\n$third\n    [,1] [,2] [,3] [,4]\n5:     5    0    0    0\n6:     0    6    0    0\n7:     0    0    7    0\n8:     0    0    0    8\n\nmod <- collapse_omega(mod, range = c(2, NA), name = \"remainder\")\nomat(mod)\n\n$first\n    [,1] [,2] [,3]\n1:     1    0    0\n2:     0    2    0\n3:     0    0    3\n\n$remainder\n    [,1] [,2] [,3] [,4] [,5]\n4:     4    0    0    0    0\n5:     0    5    0    0    0\n6:     0    0    6    0    0\n7:     0    0    0    7    0\n8:     0    0    0    0    8\n\n\n\n\n9 Deprecated simeta(n) and simeps(n)\nWe recently rolled out a feature where the user could call simeta() and pass an integer that would indicate a single ETA() to update, leaving the others alone. This proved to be more than a little dangerous when $OMEGA had off-diagonal elements. We will be deprecating this feature starting with version 1.0.0. When you load a model that contains simeta(n) or simeps(n), there will be a warning about the syntax. The warning includes some code you can write to silence the warning, but this will be temporary. In a future release, we will always warn when this syntax us used and eventually generate an error. It is recommended to always use simeta() or simeps() when re-simulating random effects."
  },
  {
    "objectID": "posts/2022-10-import-multiple.html",
    "href": "posts/2022-10-import-multiple.html",
    "title": "Import estimates from multiple NONMEM runs",
    "section": "",
    "text": "The $NMEXT and $NMXML blocks allow you to import estimates (THETA, SIGMA, and OMEGA) from a NONMEM run. So if you are running a population PK model in NONMEM and translating to mrgsolve, you should never need to copy the final estimate but rather read them in using these blocks.\nIf you are running sequential PK/PD or parent/metabolite models, you might need to pull estimates from multiple NONMEM runs. This is easy to do with multiple $NMEXT (or $NMXML) blocks."
  },
  {
    "objectID": "posts/2022-10-import-multiple.html#import-the-first-pk-model",
    "href": "posts/2022-10-import-multiple.html#import-the-first-pk-model",
    "title": "Import estimates from multiple NONMEM runs",
    "section": "1 Import the first (PK) model",
    "text": "1 Import the first (PK) model\nFirst, grab the estimates from the PK model; let’s call it run 101. The $NMEXT block could look like this\n\n$NMEXT\nrun = 101\nproject = \"../model/nonmem\"\nroot = \"cppfile\"\n\nThis will find the file 201.ext in the ../model directory which is taken to be relative to the location of the mrgsolve model file (using the root argument). If the paths are a little confusing, you can try installing the here package and using\n\n$NMEXT\nrun = 101\nproject = here::here(\"model/nonmem\")\n\nThis would require an Rstudio project file in the (project) root directory and then we would locate the NONMEM run relative to that project root (e.g. in <project-root>/model/nonmem).\nOnce the first model is imported, we now have access to THETA1, THETA2 etc from the PK model."
  },
  {
    "objectID": "posts/2022-10-import-multiple.html#import-the-second-pd-model",
    "href": "posts/2022-10-import-multiple.html#import-the-second-pd-model",
    "title": "Import estimates from multiple NONMEM runs",
    "section": "2 Import the second (PD) model",
    "text": "2 Import the second (PD) model\nNow, we import estimates from the PD model run (let’s call it 201) using another call to $NMEXT\n\n$NMEXT\nrun = 201\nproject = here::here(\"model/nonmem\")\ntname = \"theta\"\n\nThis is the second import in the same mrgsolve model file, so we change the handle for referencing the THETA estimates: now the PD model uses theta1, theta2 etc so that we can retain the THETA numbering for both the PK and PD models, remembering that the PD model uses theta1 (lower case) while the PK model uses THETA1 (upper case). Note that we have to change the handle (to something like theta) otherwise mrgsolve will throw an error because there would be two THETA1 in the parameter list."
  },
  {
    "objectID": "posts/2022-apr-stop.html",
    "href": "posts/2022-apr-stop.html",
    "title": "Stopping long-running simulations",
    "section": "",
    "text": "Sometimes you have a simulation that is running longer than it needs to run or longer than you want it to run.\n\nlibrary(mrgsolve)\nlibrary(tidyverse)\n\nSome examples include\n\nyou create a large input data set and send it off for simulation, but you discovered an error in the code while the simulation was running\nmaybe the simulation is running longer than you thought it would and you want to kill it to take a closer look\nyou have run the system until some critical event happened (the patient was cured!) and you really don’t need to simulate that last 5 year of treatment\nyou want to let a simulation run for 3 minutes maximum; if it is not done by then, just give up and move on\n\nThis blog post is about stopping those runs and most of the time, this requires writing a bit of code into the model.\n\n1 User interrupt\nWhen mrgsolve is simulating a data set, it stops every so often to check for the user interrupt signal (Control-C or Esc). So if you have some regrets after starting a simulation, hit Control-C or Esc a bunch of times and that will eventually stop the simulation.\nmrgsolve has to stop to check for user interrupt; we don’t want to stop to frequently so as to hurt performance, but we don’t want to stop too infrequently either - that would make you have to wait too long to stop the simulation. By default, mrgsolve counts the records that is processes and stops every256 records to look for the interrupt. This default value can be checked or modified as the interrupt argument to mrgsim() and friends. If you have both observations and records in your data set, this check interval will roughly correspond to every 256 output records. I say roughly because mrgsolve also counts some records that aren’t in your data set but still get implemented (like turning off an infusion). You might want it to look more frequently if you have a model that is very difficult to solve or if you have long spans of time between records. You might want to check less often if the model is very easy to solve. You can set interrupt to a negative number to have is avoid checking at all. Most of the time, it is not necessary to change the check interval.\n\n\n2 Stopping a model early\nmrgsolve has some C++ functions that you can write into your model that will stop the simulation once some condition is met. The functions are\n\nself.stop()\nself.stop_id()\nself.stop_id_cf()\n\nWe’ll walk through each of them.\nTo stop the simulation and throw an error, use\n\nself.stop();\n\nThis can be called in $MAIN or $TABLE and it will just stop the simulation with an error message. You can catch this condition by wrapping the simulation call in try()\n\noutput <- try(mrgsim(model, data))\n\nand then check to see if the simulation failed\n\nif(inherits(output, \"try-error\")) {\n  # bail out  \n} else {\n  # keep going  \n}\n\nIf you want to just stop simulating the current individual, you can use\n\nself.stop_id();\n\nor\n\nself.stop_id_cf();\n\nBoth of these will stop simulating the current subject and then move on to the next subject. The difference in behavior comes from what gets filled in for the remaining records for that subject.\n\nself.stop_id() fills in the remaining rows with NA_real_ so that an easy way to find the stopping point is to select records where ID is not NA\nself.stop_id_cf() fills in the remaining rows with the last simulated value; this approach might be useful in more limited circumstances, but available if needed\n\n\n\n3 Setting a maximum run time\nIt is possible to limit the simulation time for an individual or for the entire problem. This isn’t handled automatically by mrgsolve, but we’ll show you how to write a small bit of code to do this in a very flexible way.\nRecall that the $PREAMBLE block gets called once at the start of the problem.\n\n$GLOBAL\n#include <time.h>\n\n$PREAMBLE\ntime_t tstart = time(0);\n\nIn $PREAMBLE, I got the current time with time(0) and saved it to tstart The units for start are seconds. Also note that we had to #include the header file (<time.h>) to get that function.\nNow, we’ll write some code to check the elapsed time in $TABLE and set a maximum run duration in $PARAM\n\n$PARAM MAXTIME = 180\n\n$TABLE\nif( (tstart - time(0) ) > MAXTIME) {\n  self.stop_id();\n}\n\nSo once the run time exceeds MAXTIME (180 seconds), we will stop the run graciously using self.stop_id(). You could make a case for using self.stop() here too, but you get the picture: you can determine (1) when to check the duration (2) what is the maximum duration (3) what to do when the maximum duration is exceeded, etc. The behavior is really up to you with a little bit of coding.\nI like this pattern and have plans to write a [ plugin ] that will make coding this a little easier. Stay tuned."
  },
  {
    "objectID": "posts/sir.html",
    "href": "posts/sir.html",
    "title": "Tidy workflow for simulating dynamics in R",
    "section": "",
    "text": "I worked an example for a SIR model to show people in the ecology field how they can use mrgsolve for their ODE-based models.\n\n1 Write the SIR model\n\nlibrary(mrgsolve)\nlibrary(tidyverse)\n\nmodel <- '\n$PARAM B = 1/70, mu = 1/70, Beta = 400, gamma = 365/14\n\n$INIT S = 1-0.001-0.9, I = 0.001, R = 0.9\n\n$ODE\ndouble N = S+I+R;\ndxdt_S = B-Beta*S*I/N-mu*S;\ndxdt_I = Beta*S*I/N-(mu+gamma)*I;\ndxdt_R = gamma*I-mu*R;\n\n$TABLE\ndouble R0 = Beta/(mu+gamma);\n'\n\n\n\n2 Compile and load\n\nmod <- mcode(\"sir\", model,  end = 30, delta = 1/120)\n\nBuilding sir ... done.\n\n\n\n\n3 Simulate\n\nmod %>% mrgsim() %>% plot(scales = \"same\")\n\n\n\n\n\nout <- mrgsim(mod, output=\"df\")\n\nggplot(out, aes(S,I)) + geom_point()\n\n\n\n\n\n\n4 Challenge\nExplore the dynamics of the system for different values of the beta and b parameters by simulating and plotting trajectories as time series and in phase space (e.g., I vs. S). How the beta, B, and R0 related to the type of trajectories you get?\n\nmod %>%\n  wf_sweep(Beta, cv = 10) %>%\n  plot(R~time)\n\n\n\n\n\nmod %>%\n  wf_sweep(B, cv = 10) %>%\n  plot(R~time)\n\n\n\n\n\nidata <- tibble(Beta = seq(350,450,10))\n\nmod %>% \n  idata_set(idata) %>% \n  mrgsim() %>% \n  plot(S~time)"
  },
  {
    "objectID": "posts/map_bayes.html",
    "href": "posts/map_bayes.html",
    "title": "Generate MAP Bayes Parameter Estimates",
    "section": "",
    "text": "This tutorial illustrates how to do MAP Bayes estimation with mrgsolve.\nThe setup was adapted from an existing project, where only a single individual was considered. With some additional R coding, it could be expanded to consider multiple individuals in a single run."
  },
  {
    "objectID": "posts/map_bayes.html#what-is-this-function-doing",
    "href": "posts/map_bayes.html#what-is-this-function-doing",
    "title": "Generate MAP Bayes Parameter Estimates",
    "section": "5.1 What is this function doing?",
    "text": "5.1 What is this function doing?\n\nget the matrix for residual error\nMake sure eta is a list\nMake sure eta is properly named (i.e. ETA1 and ETA2)\nCopy eta into a matrix that is one row\nUpdate the model object (m) with the current values of ETA1 and ETA2\nSimulate from data set d and save output to out object\nIf we are just requesting predictions (if(pred)) return the simulated data\nThe final lines calculate the EBE objective function; see this paper for reference\nNotice that the function returns a single value (a number); the optimizer will minimize this value\n\n\nmapbayes <- function(eta,d,ycol,m,dvcol,pred=FALSE) {\n    \n  sig2 <- as.numeric(sigma)\n  eta <- as.list(eta)\n  names(eta) <- names(init)\n  eta_m <- eta %>% unlist %>% matrix(nrow=1)\n  m <-  param(m,eta)\n  out <- m %>% zero_re() %>% mrgsim(data=d,output=\"df\")\n  if(pred) return(out)\n  # http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3339294/\n  sig2j <- out[[dvcol]]^2*sig2\n  sqwres <- log(sig2j) + (1/sig2j)*(d[[ycol]] - out[[dvcol]])^2\n  nOn <- diag(eta_m %*% omega.inv %*% t(eta_m))\n  return(sum(sqwres,na.rm=TRUE) + nOn)\n}"
  },
  {
    "objectID": "posts/map_bayes.html#initial-estimate",
    "href": "posts/map_bayes.html#initial-estimate",
    "title": "Generate MAP Bayes Parameter Estimates",
    "section": "5.2 Initial estimate",
    "text": "5.2 Initial estimate\n\nNote again that we are optimizing the etas here\n\n\ninit <- c(ETA1=-0.3, ETA2=0.2)\n\nFit the data\n\nnewuoa is from the minqa package\nOther optimizers (via optim) could probably also be used\n\nArguments to newuoa\n\nFirst: the initial estimates\nSecond: the function to optimize\nThe other argument are passed to mapbayes\n\n\nfit <- nloptr::newuoa(init,mapbayes,ycol=\"DV\",m=mod,d=data,dvcol=\"DV\")\n\nHere are the final estimates\n\nfit$par\n\n[1]  0.4995400 -0.3274858\n\n\nHere are the simulated values\n\nslice(sim,1) %>% select(ET1, ET2)\n\n# A tibble: 1 × 2\n    ET1    ET2\n  <dbl>  <dbl>\n1 0.520 -0.273"
  },
  {
    "objectID": "posts/time_after_dose.html",
    "href": "posts/time_after_dose.html",
    "title": "Time after dose (TAD)",
    "section": "",
    "text": "1 TAD calculated as runtime argument\nFor a while, you’ve been able to get time after dose in your simulated output\n\nlibrary(mrgsolve)\nlibrary(tidyverse)\n\nmod <- modlib(\"pk1\", req = \"\")\n\nmod %>% \n  ev(amt = 100, ii = 4, addl = 3, time = 2) %>%\n  mrgsim(tad = TRUE, add = c(3.888,5.91)) %>% \n  as_tibble() %>% \n  head(n = 10)\n\n# A tibble: 10 × 4\n      ID  time   tad    CP\n   <dbl> <dbl> <dbl> <dbl>\n 1     1  0    -2     0   \n 2     1  1    -1     0   \n 3     1  2     0     0   \n 4     1  2     0     0   \n 5     1  3     1     3.07\n 6     1  3.89  1.89  3.99\n 7     1  4     2     4.05\n 8     1  5     3     4.27\n 9     1  5.91  3.91  4.22\n10     1  6     0     4.21\n\n\nThis is convenient because you can choose the output at run time, we give you the negative numbers prior to the first dose etc. This sort of calculation is possible because we let mrgsolve know ahead of time that we want this calculation done and mrgsolve makes an extra pass through the records to find when is the first dose for each individual.\n\n\n2 TAD calculated in the model\nSometimes you would like to work with time after dose in your model. This isn’t super-complicated to do but does require some programming and setup and all of that. As of mrgsolve 0.9.1, there is a special function to do these calculations for you.\n\nmod <- mread(\"time_after_dose.txt\",req = \"\")\n\n\n\n\nLooking at the [MAIN] block:\n\n\n\nWhen you call self.tad() you will get the time after dose. It’s important that this gets called on every record … specifically every dosing record. It will not work properly if it is not called every record and there is no check at this time to make sure you follow that rule. So please follow the rule.\nTo see an example:\n\n[ param ] CL = 1, V = 20, KA = 1\n\n[ pkmodel ] cmt = \"GUT,CENT\", depot = TRUE\n\n[ main ] \ncapture tadose = self.tad();\n\n[ table]\ncapture CP  = CENT/V;\n\n\nmod %>% \n  ev(amt = 100, ii = 4, addl = 3, time = 2) %>%\n  mrgsim(tad = TRUE, add = c(3.888,5.91)) %>% \n  as_tibble() %>% \n  head(n = 10)\n\n# A tibble: 10 × 5\n      ID  time   tad tadose    CP\n   <dbl> <dbl> <dbl>  <dbl> <dbl>\n 1     1  0    -2     -1     0   \n 2     1  1    -1     -1     0   \n 3     1  2     0     -1     0   \n 4     1  2     0      0     0   \n 5     1  3     1      1     3.07\n 6     1  3.89  1.89   1.89  3.99\n 7     1  4     2      2     4.05\n 8     1  5     3      3     4.27\n 9     1  5.91  3.91   3.91  4.22\n10     1  6     0      0     4.21\n\n\nYou will notice two differences between tad (output requested at run time) and tadose (values calculated in the model itself) in the output listing above:\n\ntadose is -1 before the first dose\nspecifically, tadose is -1 at the 2 hour observation record that occurs that the same time as the dose, but happens before the dose in record order\n\nThe main point if this is that you can easily obtain time after dose in the problem (model) itself to use as you program the model and also output the number into the simulated output."
  },
  {
    "objectID": "posts/simulate-ebe.html",
    "href": "posts/simulate-ebe.html",
    "title": "Simulate From EBE",
    "section": "",
    "text": "This blog post will show you how to use a single model to do both\npopulation simulation (with patient-specific covariates and random ETAs) and simulation from a specific set of empirical Bayes estimates (EBE; a specific, pre-defined set of individual parameters like what you get out of your NONMEM run). The basic implementation for this approach was pioneered by Tim Waterhouse at MetrumRG."
  },
  {
    "objectID": "posts/simulate-ebe.html#re-name-the-ebe",
    "href": "posts/simulate-ebe.html#re-name-the-ebe",
    "title": "Simulate From EBE",
    "section": "3.1 Re-name the EBE",
    "text": "3.1 Re-name the EBE\nInstead of using CL and V in your data, rename them to CLI and VI\n\npar <- rename(par, CLI = CL, VI = V)\npar\n\n# A tibble: 3 × 3\n     ID   CLI    VI\n  <dbl> <dbl> <dbl>\n1     1 0.788  63.3\n2     2 1.29   65.1\n3     3 0.909  36.5\n\n\nThe specific names you choose isn’t as important as naming them something other than what you used in the model."
  },
  {
    "objectID": "posts/simulate-ebe.html#add-parameters-to-the-model",
    "href": "posts/simulate-ebe.html#add-parameters-to-the-model",
    "title": "Simulate From EBE",
    "section": "3.2 Add parameters to the model",
    "text": "3.2 Add parameters to the model\nNow you need to add these as parameters in the model so mrgsolve will pick them up when you pass them in on the data set\n\n[ param ] \nWT = 70 , BMI = 23\nCLI = -1, VI = -1\n\nNote we gave these parameters a special value: -1. This will be important for the next step."
  },
  {
    "objectID": "posts/simulate-ebe.html#conditional-update-of-cl-and-v",
    "href": "posts/simulate-ebe.html#conditional-update-of-cl-and-v",
    "title": "Simulate From EBE",
    "section": "3.3 Conditional update of CL and V",
    "text": "3.3 Conditional update of CL and V\nNow, after the population parameters are declared and defined, you can put a block of code that updates those variables only if CLI is greater than zero; that is, if the updated parameter is something other than that special / null value, we’ll use that; otherwise use the random simulated value\n\n[ main ] \n\ndouble CL = THETA1 * pow(WT/70,0.75)    * exp(ETA(1));\ndouble V  = THETA2 * pow(BMI/23,THETA3) * exp(ETA(2));\n\nif(CLI > 0) {\n  CL = CLI;\n  V = VI;\n}"
  },
  {
    "objectID": "posts/simulate-ebe.html#include-cli-and-vi-in-the-data",
    "href": "posts/simulate-ebe.html#include-cli-and-vi-in-the-data",
    "title": "Simulate From EBE",
    "section": "3.4 Include CLI and VI in the data",
    "text": "3.4 Include CLI and VI in the data\nNow, whenever we attach these specially named parameters to the data, we’ll get a simulation from the EBE; otherwise, we’ll get the simulation from the covariates and randomly drawn ETA.\n\nlibrary(mrgsolve)\ndata <- expand.ev(amt = 100, ID = 1:3) %>% left_join(par)\ndata\n\n  ID time amt cmt evid       CLI       VI\n1  1    0 100   1    1 0.7875775 63.25656\n2  2    0 100   1    1 1.2883051 65.09495\n3  3    0 100   1    1 0.9089769 36.45781"
  },
  {
    "objectID": "posts/simulate-ebe.html#model",
    "href": "posts/simulate-ebe.html#model",
    "title": "Simulate From EBE",
    "section": "4.1 Model",
    "text": "4.1 Model\n\ncode <- '\n[ param ] \nWT = 70 , BMI = 23, KA = 1\nCLI = -1, VI = -1\n\n[ param ] THETA1 = 1, THETA2 = 30, THETA3 = 0.21\n\n[ main ] \n\ndouble CL = THETA1 * pow(WT/70,0.75)    * exp(ETA(1));\ndouble V  = THETA2 * pow(BMI/23,THETA3) * exp(ETA(2));\n\nif(CLI > 0) {\n  CL = CLI;\n  V = VI;\n}\n\n[ omega ] 0.2 0.8\n\n[ pkmodel ] cmt = \"depot,cent\", depot = TRUE\n\n[ error ] \ndouble cp = cent/V;\n'\nmod <- mcode(\"ebe\", code, capture = \"CL,V,cp\")\n\nBuilding ebe ... done."
  },
  {
    "objectID": "posts/simulate-ebe.html#simulate",
    "href": "posts/simulate-ebe.html#simulate",
    "title": "Simulate From EBE",
    "section": "4.2 Simulate",
    "text": "4.2 Simulate\n\nout <- mrgsim(mod, data, end = 72) \nplot(out, \"CL,V,cp\")"
  },
  {
    "objectID": "posts/simulate-ebe.html#check",
    "href": "posts/simulate-ebe.html#check",
    "title": "Simulate From EBE",
    "section": "4.3 Check",
    "text": "4.3 Check\nVerify that the CL and V in the output match the CLI and VI in the input\n\ndata\n\n  ID time amt cmt evid       CLI       VI\n1  1    0 100   1    1 0.7875775 63.25656\n2  2    0 100   1    1 1.2883051 65.09495\n3  3    0 100   1    1 0.9089769 36.45781\n\ncount(as_tibble(out), ID, CL, V)\n\n# A tibble: 3 × 4\n     ID    CL     V     n\n  <dbl> <dbl> <dbl> <int>\n1     1 0.788  63.3    74\n2     2 1.29   65.1    74\n3     3 0.909  36.5    74"
  },
  {
    "objectID": "posts/simulate-ebe.html#random-simulation",
    "href": "posts/simulate-ebe.html#random-simulation",
    "title": "Simulate From EBE",
    "section": "4.4 Random simulation",
    "text": "4.4 Random simulation\nNow, if we drop the EBE from the data, we get our random basic random simulation\n\ndata2 <- mutate(\n  data, \n  CLI = NULL, \n  VI = NULL, \n  BMI = c(20, 23, 26), \n  WT = c(60, 70, 80)\n)\nmrgsim_df(mod, data2) %>% count(ID, CL, V)\n\n  ID       CL        V  n\n1  1 2.002942 38.62481 26\n2  2 1.392939 54.66642 26\n3  3 1.047866 41.42735 26\n\nmrgsim_df(mod, data2) %>% count(ID, CL, V)\n\n  ID       CL         V  n\n1  1 1.372742 221.93263 26\n2  2 1.784479  19.98884 26\n3  3 1.777794  15.60165 26"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mrgsolve blog",
    "section": "",
    "text": "Update: Validate translation from NONMEM\n\n\n\n\n\n\n\nvalidation\n\n\n\n\nWith mrgsolve version 1.0.8, there is a more complete way to validate your model against a completed NONMEM estimation run.\n\n\n\n\n\n\nMar 6, 2023\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nNew in 1.0.8\n\n\n\n\n\n\n\nnew release\n\n\n\n\nFind out what’s new in mrgsolve version 1.0.8\n\n\n\n\n\n\nMar 4, 2023\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nImport estimates from multiple NONMEM runs\n\n\n\n\n\nYou can use $NMEXT and $NMXML to import estimates from multiple NONMEM runs into a single mrgsolve model.\n\n\n\n\n\n\nOct 2, 2022\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nValidate model translation from NONMEM\n\n\n\n\n\n\n\nmodel specification\n\n\nvalidation\n\n\n\n\nIf your mrgsolve model is a translation of a completed NONMEM model run, you can validate it every time; find out how.\n\n\n\n\n\n\nMay 25, 2022\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nStopping long-running simulations\n\n\n\n\n\n\n\nstop\n\n\n\n\nSometimes, you want to stop a simulation that is running (or might run) longer than you want. Find out how.\n\n\n\n\n\n\nApr 23, 2022\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nNew in 1.0.0\n\n\n\n\n\n\n\nnew release\n\n\n\n\nmrgsolve celebrates her version 1.0.0 release. Find out about some very cool and powerful features that we included in this release.\n\n\n\n\n\n\nJan 1, 2022\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nSimulate From EBE\n\n\n\n\n\n\n\nEBE\n\n\n\n\nThis blog post will show you how to use a single model to do both population simulation and simulation from a specific set of empirical Bayes estimates. The basic implementation for this approach was pioneered by Tim Waterhouse at MetrumRG.\n\n\n\n\n\n\nSep 1, 2021\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nNew in 0.11.0 and 0.11.1\n\n\n\n\n\n\n\nnew release\n\n\n\n\nFind out what’s new in mrgsolve version 0.11.0 and 0.11.1.\n\n\n\n\n\n\nAug 16, 2021\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nNew in 0.10.7\n\n\n\n\n\n\n\nnew release\n\n\n\n\nFind out what’s new in mrgsolve version 0.10.7.\n\n\n\n\n\n\nDec 1, 2020\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nNew in 0.10.0 and 0.10.1\n\n\n\n\n\n\n\nnew release\n\n\n\n\nFind out what’s new in mrgsolve version 0.10.0 and 0.10.1.\n\n\n\n\n\n\nFeb 1, 2020\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nZero-order steady state infusion\n\n\n\n\n\n\n\nevents\n\n\ninfusion\n\n\nsteady state\n\n\n\n\nStarting with version 0.10.0, mrgsolve can implement dosing records calling for a zero-order infusion at steady state. Find out more in this blog post.\n\n\n\n\n\n\nJan 1, 2020\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nSteady State in mrgsolve\n\n\n\n\n\n\n\nsteady state\n\n\n\n\n\n\n\n\n\n\n\nDec 1, 2019\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nTime after dose (TAD)\n\n\n\n\n\n\n\ntime after dose\n\n\ntad\n\n\n\n\nIn this post, we’ll look at different ways you can bring time after dose into your simulated outputs.\n\n\n\n\n\n\nJun 1, 2019\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nAlternate dosing event syntax\n\n\n\n\n\n\n\nevents\n\n\n\n\nA fun syntax for creating event objects for different dosing regimens.\n\n\n\n\n\n\nJan 1, 2019\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nValidating Simulation Results with pmxTools\n\n\n\n\n\n\n\nvalidation\n\n\n\n\nIn this blog post, we run some simulations with mrgsolve and the excellent pmxTools package and compare results.\n\n\n\n\n\n\nJan 1, 2019\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nRmarkdown model specification\n\n\n\n\n\n\n\nmodel specification\n\n\n\n\nI came up with this fun model specification format that looks just like Rmarkdown code chunks.\n\n\n\n\n\n\nJan 1, 2019\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nTidy workflow for simulating dynamics in R\n\n\n\n\n\n\n\nexample\n\n\n\n\n\n\n\n\n\n\n\nJan 1, 2019\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nModeled interventions in mrgsolve\n\n\n\n\n\n\n\nmodeled events\n\n\nmtime\n\n\n\n\nThis post is to introduce modeled interventions in mrgsolve. The main use case is to force mrgsolve to advance the system to a specific time so that some aspect of the system can change at that time.\n\n\n\n\n\n\nJan 1, 2018\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nmtime\n\n\n\n\n\n\n\nmodeled events\n\n\nmtime\n\n\n\n\nThis is just a post on a simplified implementation of modeled events in mrgsolve. There is also another, more complete blog post on this topic published previously .\n\n\n\n\n\n\nJan 1, 2018\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nModels without compartments\n\n\n\n\n\n\n\npred\n\n\nmodel specification\n\n\n\n\nIntroducing a new model block ($PRED) that lets you write models with analytical solutions.\n\n\n\n\n\n\nJan 1, 2018\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nGenerating input data sets for mrgsolve\n\n\n\n\n\n\n\ndata set\n\n\n\n\nAn important mechanism for creating robust, complex simulations is the input data set. In this blog post, we’ll look at some ways you can quickly create input data sets for your simulation.\n\n\n\n\n\n\nJan 1, 2017\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nMixture model example\n\n\n\n\n\n\n\nmixture model\n\n\n\n\nIn this post, we’ll look at how you can code up a mixture model in mrgsolve.\n\n\n\n\n\n\nJan 1, 2017\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nA Complete Example\n\n\n\n\n\n\n\nexample\n\n\n\n\nWe had a user who was learning mrgsolve ask for a “complete example”. I wasn’t sure what exactly that meant, but I created this example and I’m sharing it today on the blog.\n\n\n\n\n\n\nJan 1, 2017\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nReproducible results with set.seed\n\n\n\n\n\n\n\nexample\n\n\n\n\nThis post demonstrates that random simulation outputs can be made reproducible by using set.seed().\n\n\n\n\n\n\nJan 1, 2017\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nGenerate MAP Bayes Parameter Estimates\n\n\n\n\n\n\n\nMAP Bayes\n\n\n\n\nThis tutorial illustrates now to do MAP Bayes estimation with mrgsolve.\n\n\n\n\n\n\nJan 2, 2016\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nMAP Bayes example\n\n\n\n\n\n\n\nMAP Bayes\n\n\noptimization\n\n\n\n\n\n\n\n\n\n\n\nJan 1, 2016\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nWork with event objects\n\n\n\n\n\n\n\nevents\n\n\n\n\nevent objects are data.frame-like data structures that allow you to quickly and flexibly include dosing interventions into your simulations.\n\n\n\n\n\n\nJan 1, 2016\n\n\nKyle Baron\n\n\n\n\n\n\n\n\nSet initial conditions\n\n\n\n\n\n\n\ninitial conditions\n\n\n\n\nThere are several ways to set initial conditions in mrgsolve. Find out how this can work to your advantage when planning your simulations.\n\n\n\n\n\n\nJan 1, 2016\n\n\nKyle Baron\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "A non-blog blog about mrgsolve. Find more mrgsolve-related resources at mrgsolve.org."
  }
]