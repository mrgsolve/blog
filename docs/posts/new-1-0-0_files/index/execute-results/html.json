{
  "hash": "5820708b21137a5ad6be6cead65960b6",
  "result": {
    "markdown": "---\ntitle: \"New in version 1.0.0\"\nauthor: \"Kyle Baron\"\ndate: \"4/24/2022\"\ncategories: [release, whats new]\n---\n\nThere are a bunch of new features out now in the mrgsolve 1.0.0 release. Most \nof these are related to model syntax (what / how you write your model in the \n`.mod` or `.cpp` file) rather than model functionality. \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mrgsolve)\nlibrary(tidyverse)\n```\n:::\n\n# Use THETA(n) to refer to THETAn\n\nAll models will be able to use `THETA(n)` to refer to `THETAn`. For example:\n\n\n::: {.cell}\n\n```{.c .cell-code}\n[ nmxml ] \nrun = 100\nroot = \"cppfile\"\n\n[ main ] \ndouble CL = THETA(1) * pow(WT/70, 0.75);\n```\n:::\n\nYou'll notice that we referred to a nonmem run with `[ nmxml ]` so this syntax\nis meant be one small step toward making it easier to translate your model \nfrom the nonmem control stream to mrgsolve format. This is pretty simple, but \nwill mean less time removing parentheses when copying over model code. \n\n# New plugin called `autodec`\n\nPlugins are extra functionality that you can invoke when coding your model. \nFor example, plugins exist for calculating time after dose, adding Rcpp \nfunctionality to your model etc and [more](https://mrgsolve.org/user_guide/model-specification.html#block-plugin).\n\nOne new plugin is called `autodec`. This plugin will automatically declare \nC++ variables for you. For example, I can code the snipped from the previous\nblock using `autodec` plugin and mrgsolve will discover that `CL` needs to be\ndeclared:\n\n::: {.cell}\n\n```{.c .cell-code}\n[ plugin ] autodec\n\n[ nmxml ] \nrun = 100\nroot = \"cppfile\"\n\n[ main ] \nCL = THETA(1) * pow(WT/70, 0.75);\n```\n:::\n\nThe motivation behind this feature is to make it easier to code models with \nlots of variables when all your variables are simple double precision floating \npoint numbers.\n\n# New plugin called `nm-vars`\n\nThis plugin provided a nonmem-like syntax for _certain model elements_, \nincluding \n\n- `Fn`, `Dn`, `Rn`, and `ALAGn`\n- `A(n)`, `A_0(n)` and `DADT(n)`\n- `T` (used for `SOLVERTIME` in `$ODE`)\n\nSo your mrgsolve model translated from nonmem might look like this\n\n::: {.cell}\n\n```{.r .cell-code}\nsee(modlib(\"nm-like\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nBuilding nm-like ... done.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.c .cell-code}\n$PROB Model written with some nonmem-like syntax features\n\n$PLUGIN nm-vars autodec\n\n$PARAM\nTHETA1 = 1, THETA2 = 21, THETA3 = 1.3, WT = 70, F1I = 0.5, D2I = 2\nKIN = 100, KOUT = 0.1, IC50 = 10, IMAX = 0.9\n\n$CMT @number 3\n\n$PK\nCL = THETA(1) * pow(WT/70, 0.75); \nV  = THETA(2); \nKA = THETA(3);\n\nF1 = F1I;\nD2 = D2I;\nA_0(3) = KIN / KOUT;\n\n$DES \nCP = A(2)/V;\nINH = IMAX*CP/(IC50 + CP);\n  \nDADT(1) = -KA*A(1);\nDADT(2) =  KA*A(1) - (CL/V)*A(2);\nDADT(3) =  KIN * (1-INH) - KOUT * A(3);\n\n$ERROR\nCP = A(2)/V;\n```\n:::\n\nNotice that __not all nonmem syntax is supported__; just select data structures\nthat use `A` and `DADT` to refer to compartments and differential equations.\nAlso notice that we still require `;` at the end of each line and we still \nneed to use `pow(base, exponent)` to calculate exponent of some number. \n\n# Compartment\n\nThe `$CMT` block has two new options: `@number` and `@prefix` that let you \nquickly specify a numbered series of compartments in the model similar to \nnonmem. The default `@prefix` is `A` so that this code\n\n::: {.cell}\n\n```{.c .cell-code}\n$CMT @number 3\n```\n:::\n\nwill put compartments `A1`, `A2`, `A3` into your model. \n\n# New model in `modlib`: `nm-like`\n\nYou can see a model coded with these new syntax features in the internal model\nlibrary; the model is called `nm-like`\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- modlib(\"nm-like\")\nsee(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nModel file:  nm-like.cpp \n$PROB Model written with some nonmem-like syntax features\n\n$PLUGIN nm-vars autodec\n\n$PARAM\nTHETA1 = 1, THETA2 = 21, THETA3 = 1.3, WT = 70, F1I = 0.5, D2I = 2\nKIN = 100, KOUT = 0.1, IC50 = 10, IMAX = 0.9\n\n$CMT @number 3\n\n$PK\nCL = THETA(1) * pow(WT/70, 0.75); \nV  = THETA(2); \nKA = THETA(3);\n\nF1 = F1I;\nD2 = D2I;\nA_0(3) = KIN / KOUT;\n\n$DES \nCP = A(2)/V;\nINH = IMAX*CP/(IC50 + CP);\n  \nDADT(1) = -KA*A(1);\nDADT(2) =  KA*A(1) - (CL/V)*A(2);\nDADT(3) =  KIN * (1-INH) - KOUT * A(3);\n\n$ERROR\nCP = A(2)/V;\n```\n:::\n:::\n\nHere, I've coded the `THETA`s in a parameter block; these would ordinarily \ncome into the model via `$NMXML` or `$NMEXT`, which automatically import these\nparameters and estimates. But note that we can still refer to `THETA(1)` and \nothers ... this resolves to `THETA1` regardless.\n\n\n# Audit \n\nWhen mrgsolve loads your model, it checks the `$ODE` block to make sure you have\ndifferential equations for every compartment in your model. A long time ago, \nI started calling this check `audit` and it was something that was on by default\nbut could be turned off via the call to `mread()`. \n\nStarting with version 1.0.0, `audit` can be controlled at the `$ODE` block \nlevel like this\n\n::: {.cell}\n\n```{.c .cell-code}\n[ ode ] @audit\n\ndxdt_A1 = ...\ndxdt_A2 = ...\n```\n:::\n\nto explicitly tell mrgsolve to audit the equations or\n\n::: {.cell}\n\n```{.c .cell-code}\n[ ode ] @!audit\n\ndxdt_A1 = ...\ndxdt_A2 = ...\n```\n:::\n\nto disable the audit. The audit is on by default and should only be turned off\nwhen you have written some special construct in `[ ode ]` to code the \ndifferential equations (e.g. odes are written programmatically). \n\n\n# New time spacer for event sequences\n\nThe new feature is an `ii` spacer for sequences of event objects. \n\nUsing [event objects](https://mrgsolve.org/user_guide/event-chapter.html), \nwe can create complicated dosing regimens from simpler ones. For example, we\nmight have a week of 50 mg dosing followed by a week of 100 mg dosing and then \nup to 200 mg dosing. We can accomplish that with an event sequence\n\nFirst create the individual pieces\n\n::: {.cell}\n\n```{.r .cell-code}\na <- ev(amt = 50,  ii = 24, addl = 6)\nb <- ev(amt = 100, ii = 24, addl = 6)\nc <- ev(amt = 200, ii = 24, addl = 6)\n```\n:::\n\nThen put them in a sequence\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- ev_seq(a, b, c)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEvents:\n  time amt ii addl cmt evid\n1    0  50 24    6   1    1\n2  168 100 24    6   1    1\n3  336 200 24    6   1    1\n```\n:::\n:::\n\nWhen they are sequenced, you'll see that the second piece (`b`) starts one\ndosing interval after the last dose in the first piece (`a`). \n\nWe can put a 24 hour spacer between `a` and `b`\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(a, wait = 24, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEvents:\n  time amt ii addl cmt evid\n1    0  50 24    6   1    1\n2  192 100 24    6   1    1\n```\n:::\n:::\n\nHere, the last dose in `a` is given, we wait one dosing interval (24 hours) then \nwait another 24 hours (via `wait`) and then start `b`. \n\nRather than using `wait`, we can use `ii` to specify the amount of time \nfrom the last dose in `a` to the first dose in `b`. So if we want to wait 3 days\nbetween the last dose in `a` and the first dose in `b`\n\n::: {.cell}\n\n```{.r .cell-code}\nev_seq(a, ii = 3*24, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEvents:\n  time amt ii addl cmt evid\n1    0  50 24    6   1    1\n2  216 100 24    6   1    1\n```\n:::\n:::\n\nNotice that this same behavior can be achieved with `wait` but using `ii` \nmight be easier to interpret in some cases. \n\n#  Collapse matrices\n\nSometimes in your model, you have multiple OMEGA or SIGMA blocks like this\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- '\n$OMEGA  @name first\n1 2 3\n\n$OMEGA @name second\n4\n'\nmod <- mcode(\"collapse\", code, compile = FALSE)\n\nomat(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$first\n    [,1] [,2] [,3]\n1:     1    0    0\n2:     0    2    0\n3:     0    0    3\n\n$second\n    [,1]\n4:     4\n```\n:::\n:::\n\n\nIf I want to update these values but I only have a 4x4 matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]  0.1  0.0  0.0  0.0\n[2,]  0.0  0.2  0.0  0.0\n[3,]  0.0  0.0  0.3  0.0\n[4,]  0.0  0.0  0.0  0.4\n```\n:::\n:::\n\nI can't do it; mrgsolve wants a 3x3 matrix for the first slot and 1x1 matrix\nfor the second. \n\nA new function will collapse the model matrix into larger matrices\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- collapse_omega(mod)\nomat(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$...\n    [,1] [,2] [,3] [,4]\n1:     1    0    0    0\n2:     0    2    0    0\n3:     0    0    3    0\n4:     0    0    0    4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- update(mod, omat = mat)\nomat(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$...\n    [,1] [,2] [,3] [,4]\n1:     1    0    0    0\n2:     0    2    0    0\n3:     0    0    3    0\n4:     0    0    0    4\n```\n:::\n:::\n\nYou can't split matrices up into smaller chunks, but if there are more than \ntwo blocks, you can select which blocks to join\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- '\n$OMEGA  @name first\n1 2 3\n\n$OMEGA @name second\n4\n\n$OMEGA @name third\n5 6 7 8\n'\nmod <- mcode(\"collapse2\", code, compile = FALSE)\n\nomat(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$first\n    [,1] [,2] [,3]\n1:     1    0    0\n2:     0    2    0\n3:     0    0    3\n\n$second\n    [,1]\n4:     4\n\n$third\n    [,1] [,2] [,3] [,4]\n5:     5    0    0    0\n6:     0    6    0    0\n7:     0    0    7    0\n8:     0    0    0    8\n```\n:::\n\n```{.r .cell-code}\nmod <- collapse_omega(mod, range = c(2, NA), name = \"remainder\")\nomat(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$first\n    [,1] [,2] [,3]\n1:     1    0    0\n2:     0    2    0\n3:     0    0    3\n\n$remainder\n    [,1] [,2] [,3] [,4] [,5]\n4:     4    0    0    0    0\n5:     0    5    0    0    0\n6:     0    0    6    0    0\n7:     0    0    0    7    0\n8:     0    0    0    0    8\n```\n:::\n:::\n\n\n# Deprecated simeta(n) and simeps(n)\n\nWe recently rolled out a feature where the user could call `simeta()` and \npass an integer that would indicate a single `ETA()` to update, leaving the \nothers alone. This proved to be more than a little dangerous when `$OMEGA`\nhad off-diagonal elements. We will be deprecating this feature starting \nwith version 1.0.0.  When you load a model that contains `simeta(n)` or \n`simeps(n)`, there will be a warning about the syntax. The warning \nincludes some code you can write to silence the warning, but this will be \ntemporary. In a future release, we will always warn when this syntax us used\nand eventually generate an error. It is recommended to always use `simeta()`\nor `simeps()` when re-simulating random effects. \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}